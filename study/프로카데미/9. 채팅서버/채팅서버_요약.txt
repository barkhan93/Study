-----------------------------------------------------------------------
LanClient <-> LanServer

서버끼리의 통신. 신뢰성있는 송수신으로 믿고감.

-----------------------------------------------------------------------

LanServer의 사용자쪽 (CMyLanServer) 함수

OnEnterJoinServer() = 0;  서버와의 연결 성공 후  
OnLeaveServer() = 0; 	  서버와의 연결이 끊어졌을 때

OnRecv(Packet*) = 0;      하나의 패킷 수신 완료 후
OnSend(int SendSize) = 0; 패킷 송신 완료 후

OnWorekrThreadBegin = 0;
OnWorkerThreadEnd() = 0;

OnError(int errorcode, wchar*) = 0;

-----------------------------------------------------------------------

LanClient

하나의 Session만 존재하면 될것이므로, 크게 신경쓸 것이 없음

-----------------------------------------------------------------------

NetClient <-> NetServer

서버-클라(사용자) 간의 통신. 
약간의 암호화가 들어가야 하므로, 프로토콜 헤더쪽이 달라진다.

-----------------------------------------------------------------------

Connect의 사용

클라쪽에서는 지금껏 Connect만을 사용했음.
block으로 가도 상관없으나, 앱이멈추는것은 X
따라서 Nonblock소켓으로 제어하게끔 해야하지만 Overlapped까지는 X

-----------------------------------------------------------------------

Non-block소켓으로 Connect사용

Non-block소켓으로 진행하는 경우 Connect가 항상 실패.
Non-block소켓으로 Select(timeout 300m/s)를 지정하여,
성공 유무를 판단한다.

-----------------------------------------------------------------------

LanServer - LanClient

에코서버이고 Session이 하나밖에 존재하지않으므로,
동기화 이슈가 날만한 곳이 없음.

문제는 연결/재연결이 반복될떄 나타나게 될것이다.

-----------------------------------------------------------------------

NetServer - NetClient

일반클라와의 연결에서는 약간의 안전장치를 넣기위해,
인코딩/디코딩용 함수를 구현한다.

1byte 고정 Key(상수값)
1byte 랜덤 Key(직렬화버퍼가 만들어질때마다 랜덤값 생성)

-----------------------------------------------------------------------

랜덤 키

Code(1) - Len(2) - [RandKey(1)] - CheckSum(1) - Payload(Len)

비트단위가 아닌 byte단위로 나눠서 헤더를 사용하면,
프로토콜 자체 패턴이 노출되므로 랜덤키를 넣어서 감춤.

-----------------------------------------------------------------------

암호화

암호화대상은 CheckSum + PayLoad이며, 나머지는 그대로 노출한다.

RandKey는 어차피 헤더안에 포함되고, XOR하면 풀리기때문에 의미X

-----------------------------------------------------------------------

RandKey를 암호화하지않는 이유

K = 고정키
R = 랜덤키


PayLoad = Data ^ R ^ K

RandKey = R ^ K


패킷전체 모양
[Code - Len - RandKey - CheckSum - PayLoad]


이때 RandKey에 R키와 K키가 모두 있으므로 PayLoad로 XOR하면 복호화성공.

XOR은 어설프게 하느니 안하느니만 못하기 때문에 주의.

-----------------------------------------------------------------------

체크섬

체크섬은 PayLoad를 대상으로하고, 체크섬과 PayLoad를 암호화한다.

복호화했을때 이값이 진짜 값인지 틀린값인지 알수없음.
따라서 이때 체크섬으로 값이 진짜인지 확인하는 용도로 사용.

-----------------------------------------------------------------------

지금과같은 체크섬-암호화의 목적


최대한 가볍게 데이터패턴을 감추고자하는 것.

암호화는 3자로부터 방어를 위한것이나
우리게임클라는 누구나 받을수 있기때문에 암호화가 크게의미X

핵같은 경우 서버에서 판정으로 막는다.

-----------------------------------------------------------------------

패킷 암호화 조건

1. 키 용량이 적을것
2. 패킷 생성시 마다 키가 변경되게끔 (같은패킷이라도 항상 다른패턴)
3. 데이터 패턴 감추기
4. 키를 잘못입력하면 잘못된 결과.

K(고정키) = 클라-서버간 쌍방의 상수값.
R(랜덤키) = 클라-서버 송수신 패킷헤더에 포함됨


<암호화형태는 별도확인>

-----------------------------------------------------------------------

헤더 세팅

LanServer에 암호화기능을 넣은것으로 NetServer를 완성시킴.

이 헤더는 네트워크 라이브러리의 입장이므로 컨텐츠쪽의 헤더역시
PayLoad로 인식한다.

-----------------------------------------------------------------------

헤더 접근

패킷을 다루는 직렬화버퍼의 앞 5byte는 private으로 막는다.
네트워크 라이브러리만이 접근해서 사용가능하게끔 한다.

컨텐츠쪽에서는 이 5byte뒤쪽에 데이터를 넣어 송/수신 요청을 함

-----------------------------------------------------------------------

Setheader()

바깥에서 접근을 막고, 헤더를 세팅해주는 함수를 따로마련.

Encoding() / Setheader로 암호화/체크섬 간결화

-----------------------------------------------------------------------

CallOnce

C++11에서 나온 문법
한번만 호출해야할때 Call Once권장.

내부적으로 Mutex가 들어감(Mutex include)

-----------------------------------------------------------------------

멀티스레딩 환경에서 싱글톤


if(p == nullptr) new Data;

위와같은 로직은 멀티스레딩 환경에서 안전하지않음.

인터락으로 변수를두고 체크하여 접근을 막는다고해도,
접근이 제한된 쪽에서 할수있는 것이 없음.

-----------------------------------------------------------------------

SendPacket 내부

[ Setheader -> Encoding -> SendQ.Enqueue -> SendPost ]

-----------------------------------------------------------------------

인코딩

하나의 패킷을 여러세션에게 보낼 때,
flag를 두고 한번만 인코딩을 하는것은 멀티스레드환경에서 안전하지않음.

락을 사용한다면 병렬처리를 기대하기 힘들 것.

-----------------------------------------------------------------------

직렬화버퍼의 thread - safe

멀티스레드 환경에서 하나의 직렬화버퍼를 여러대상으로 보내는것은 불가.
(설계가 매우난해하므로, 애초에 고려하지않았음)

결국 하나의 Msg를 여러 Session한테 보낼때 SendPacket을 반복문 돌림

-----------------------------------------------------------------------

SendPacket의 불필요한 호출

[직렬화버퍼 생성, SendPacket호출]
위 행위가 짝으로 이루어지고있음.

이때 성능적으로는 여러번의 SendPacket이 불필요해 보일 수 있음

단, 인코딩을 컨텐츠쪽에서 하도록 유도하는것은 비권장.

-----------------------------------------------------------------------

Recv가 온 경우

1. 길이로 완성된 메시지인가 판단(헤더길이는 암호화대상 X)
2. 직렬화버퍼에 넣어 디코딩
3. 디코딩된 데이터를 체크섬으로 확인
4. 문제없는 경우 최종적으로 OnRecv에 전달

체크섬이 다르거나, 복호화에 실패했다면 해당 세션을 로그로 남기고 끊음.

-----------------------------------------------------------------------

채팅서버

채팅서버에서는 하나의 메시지를 여러명한테 보내는 등의 상황이 나옴.

-----------------------------------------------------------------------

로그인 서버

우리가만든 에코서버는 실제 로그인서버에 적합.
로그인 서버는 다른 세션과 연관성이 없기때문에 동기화가 없음.

단순히 ID/PAS 체크 후 끝
워커스레드는 해당 세션만을 물고 처리해도 문제 X

-----------------------------------------------------------------------

Redis(메모리 DB)

메모리에 올려놓고 빠르게 결과보관, 검색하여 뱉어줌.
전원이 내려가면 저장되지않고 사라진다.

-----------------------------------------------------------------------

MySQL 

관계가 있는 데이터 베이스
물리적인 저장이 가능

-----------------------------------------------------------------------

랭킹 서버구현 가정

유저가 1억명이라고 가정한다.
DB가 감당할수없는 숫자이므로 단독서버로 관리

클라(게임서버)가 랭킹순위를 요청하면, 랭킹서버는 데이터를 뱉음

-----------------------------------------------------------------------

랭킹 서버에 요청할 수있는 것

1. 랭킹 데이터 요청
2. 랭킹 데이터 갱신

-----------------------------------------------------------------------

랭킹서버 구현 설계

1. List를 들고 Sort하는것
2. Map을들고 삽입/삭제하는 것

이는 성능테스트를 거쳐야만 알 수있음

-----------------------------------------------------------------------

IOCP를 예시로든 스레드설계기법

1. WorkerThread에서 직접적으로 처리
2. 스레드를 따로두지않고 작업 요청 
(동시처리 X -> 동기화문제 X, 성능은 기대 X)

3. 기능별로 스레드를 분리

-----------------------------------------------------------------------

랭킹서버 설계 - 워커스레드에서 직접 처리

WorkerThread에 직접접근인 경우 Shared,
변경이 있을때 Exclusive로 갈수 잇겠음.

(Sort는 꽤긴시간을 요하고 락이 걸리기때문에 다른작업 불가)

-----------------------------------------------------------------------

랭킹서버의 느슨한 동기화

1. 정렬스레드 등장

스코어 데이터가 완벽한 실시간이 아니어도 된다면?
정렬 스레드를 따로두고 sort자체에 대한 빈도수를 낮출 수 있음

일정시간마다 sort, 또는 n개이상 요청이 쌓이는 경우 sort


2. 스레드 사본활용

원본데이터가 아닌 사본을 활용하는 방식
요청이 오는경우 사본을 뱉고, 사본은 일정 주기마다 원본데이터로 업데이트

-----------------------------------------------------------------------

랭킹서버 결론


sorting으로 Lock을걸면서 접근을 제한시키는 시간과,
한쪽이 sorting될때마다 읽기 전용으로 데이터로 카피하는 행위중

어떤것이 오버헤드가 더 클것인지 테스트를 통해 알아봐야 할 부분임

sort시 처음부터 끝까지 완전히 뒤집어 엎는게 아니므로,
오히려 오버헤드가 적을 수있음.

-----------------------------------------------------------------------

사본데이터 활용 - 테라의 논타겟팅


논타겟팅은 공격 궤적에 따라 오브젝트 검사
(검사시 락을 건다면 오브젝트 모두 멈춤)

여러스레드에서 하나의 데이터를 대상으로 충돌처리는 말이안됨.
 -> 각 스레드는 각자의 데이터를 기준으로 충돌처리함.


이는 완벽한 동기화가 아님.
따라서 1차 필터링으로 사용되고, 최종결과물은 후보군을 대상으로 판단

-----------------------------------------------------------------------

렌더 - 로직 파트분리

멀티스레드 환경에서 가장 많이 사용됨
오브젝트 락을 걸면 아무의미없으므로, 사본을 활용하는것.

보통 로직보다 렌더가 훨씬 오래걸림.
데이터 카피보다 렌더가 더 길어야 성능향상이 있을 것.

-----------------------------------------------------------------------

채팅서버 할일

채팅을 보내면 본인주변 9개 Sector에 메시지를 보냄
섹터는 플레이어 데이터를 대상으로 변경/삽입/삭제/순회 로직이 필요

-----------------------------------------------------------------------

채팅서버 설계

이때 워커스레드에서 모두 처리를 하되 섹터단위로 락을 건다면
데드락이 걸리게 된다. 

락이 엄청나게 많이 걸리기때문에 꼬일가능성 100%
락의 방향성을 정하면 될것이나 설계가 굉장히 복잡해질 것.

-----------------------------------------------------------------------

맵단위 락

맵역시도 섹터간의 이동이 존재하며, 데드락 위험성이 존재한다.

그리고 거대한 월드(하나의맵)으로 존재한다면 차라리 
동기화 걱정없는 스레드가 나을 수 있음

-----------------------------------------------------------------------

진행할 방식

WorkerThread가 하나의 UpdateThread로 Jop을 던지는 싱글스레드로 진행
필드가 하나, 동시에 처리하면 동기화 해결방법 X

-----------------------------------------------------------------------

싱글스레드 구조 오버헤드

JopQ에 대한 동기화문제, Jop Copy로 인한 오버헤드가 생길 수 있음
따라서 워커스레드 여러개가 하나의 공유자원을 대상으로 Lock을 것이
나을 수있음

따라서 성능때문이 아니라 다양한 연습을 위해 전자를 택함

-----------------------------------------------------------------------

네트워크 라이브러리에 전달되는 핸들러

OnClientJoin 	-> 	AcceptThread 내부호출
OnRecv 		-> 	WorkerTrhead 내부에서 호출
OnClientLevae	-> 	어떤 스레드에서든 호출이 가능

OnClientLeave는 I/O Count가 0이될때 ReleaseSession이 호출됨

-----------------------------------------------------------------------

현재 OnClientLeave에 내장된 문제

앞으로 진행될 채팅서버는 심플하게 가므로 이러한 문제가 나지않지만,
우리 네트워크라이브러리의 결함(?) 으로 지적당할 수 있음.


컨텐츠쪽 스레드가 여러개라면 SendPacket, OnClientLeave 동시에 호출가능

이 경우 Session락이 재귀형태가 되므로 CriticalSection을 써야함
(컨텐츠쪽에서 사용하는 락을 말함)

-----------------------------------------------------------------------

문제 예시

컨텐츠 파트에서 Player를 다루는 자료구조가 있고 동기화객체가 있음
OnClientJoin으로 Player 접속이 완료됨

Player를 Player자료구조에 삽입 -> 동기화
삽입과 동시에 컨텐츠 코드가 들어간다면 SendPacket이 들어감
근데 SendPacket내부에서 해제상황이되어 OnClientLeave()됨 -> 동기화

동기화 두번

-----------------------------------------------------------------------

문제 해결방법

1. 단순히 CS를 사용하도록 권장하기.

2. IOCount가 0이되는것과 Release를 분리하여, Release전에
라이브러리쪽에서 어떻게든 알려주는 것

-----------------------------------------------------------------------

스레드 설계시 주의점

방향성, 함수에대한 스레드의 호출규칙등을 명시

-----------------------------------------------------------------------

네트워크 라이브러리 추가기능 - TimeOut

TimeOut은 일정시간 통신이 없는 세션을 알려주는 기능
물론 TimeOut된 Session이 나왔다면 컨텐츠쪽에서 끊는것을 결정

-----------------------------------------------------------------------

TimeOut기능 구현

수신있을때 시간저장, Recv에 해당시간을 차감하여 구함
단, 송신이 아예없는 경우에는 식별 X

따라서 반응이 없는 것들을 찾아내려면, 별도의 스레드가 나오든
따로 순회를 하든 다른방법으로 찾아내야함

-----------------------------------------------------------------------

채팅서버 전제

우리채팅서버는 MMO라는 전제
클라는 게임서버/채팅서버 각각 접속해있는 상태
게임서버와 채팅서버는 아무런 연관 X

채팅서버만의 섹터가 나옴
(게임서버 기존섹터를 n*n형태로 늘려서 사용해도 무방)

-----------------------------------------------------------------------

채팅서버 설계방식

추세는 채팅서버를 분리하지않음.
귓속말 / 길드채팅 / 파티채팅은 컨텐츠를 알아야 하므로 게임서버가 포함

게임서버마다 채팅서버가 붙으면 물리서버가 너무 많아지고 관리도힘듬
-> 대부분은 통합된 하나의 채팅서버를 두도록 설계

동접이 5만명이더라도 여러개의 게임서버를 커버하는 설계로 감
더 많아지는 경우에는 어쩔수없이 나눠야 할 것

-----------------------------------------------------------------------

우리가 갈 채팅서버 설계방식

[게임서버 - 채팅서버]가 세트로 이뤄지도록 구현
플레이어는 두개의 서버에 동시접속하여 플레이함


게임서버 / 채팅서버 관계

채팅서버에서도 결국 하나의 플레이어 객체로 관리
하지만 플레이어 섹터좌표만 알면 됨(X, Y를 알필요 없음)

클라는 직접 본인 섹터를 계산, 섹터변환시 섹터좌표 송신

-----------------------------------------------------------------------

클라데이터 반영할 경우 문제

클라데이터를 믿으므로 조작이 가능 -> 채팅조작은 의미 X 
이경우 완벽한 동기화는 불가 -> 이거말고는 별다른방법 없음

-----------------------------------------------------------------------

문제를 해결하려면

게임서버가 끼어들어 채팅서버와 데이터를 주고받아야함.
이렇게 할바에 채팅서버를 없애고 게임서버로 통합하는게 나음

-----------------------------------------------------------------------

서버 설계추세

CPU코어가 많기때문에 서버분산을 하지않고,
하나의 프로세스안에서 멀티코어를 잘 활용하자는 추세

서버를 분산하면 개발/관리가 힘들어지고 버그/오버헤드가 많이발생됨

일단은 다양한 경험을 위해 [채팅서버-게임서버] 통합으로 간다

-----------------------------------------------------------------------

채팅서버 구현

섹터는 플레이어를 담아야하므로 섹터배열의 인자는 STL의 자료구조.
섹터 내부에는 플레이어 포인터, 또는 세션아이디가 들어감

-----------------------------------------------------------------------

채팅서버를 분리하지않을때 설계

OnClientJoin에서 플레이어 생성
OnRecv에서 PlayerMap에서 플레이어를 찾아 채팅보냄
Leave에서는 PlayerMap에 접근하여 플레이어 제거

-----------------------------------------------------------------------

싱글 스레드 구조

[IO를 처리하는 다수의 WorkerThread와, 하나의 UpdareThread]
이는 가장 고전적인 게임서버 설계형태임

Sector배열과 PlayerMap은 어찌됐던 락이 걸려야한다.
따라서 굳이 분리할 필요가 없다. 

그리고 하나의 스레드로 모든 Jop이 들어온다.

-----------------------------------------------------------------------

싱글스레드 구조의 단점

IOCP입장에서는 비효율적이라고 볼수있는 형태.
그래도 Select, APC, Event보다는 나음.

여러 스레드를 기능별로 빼기때문에, 코어를 다 활용하지 못할 정도로
비효율적이지는 않음

-----------------------------------------------------------------------

싱글스레드 구조의 병렬처리를 위한 설계

1. SRWLock을 Read/Write Lock으로 분리
2. 섹터 배열, PlayerMap이외에도 섹터하나 마다 락을 걸고감

2번의 경우 데드락걸릴 가능성높음
이렇게 갈바에는 전체 락이 나음

-----------------------------------------------------------------------

3. 싱글스레드 구조 - 맵단위 락


섹터가 매우많고 클라가 서로 영향을 주지않는다면 맵끼리만 락
한번에 한맵에 있는 유저들의 메시지만 오는 경우는 적음
왠만큼의 병렬처리 기대가능

하지만 PlayerMap은 하나임.
-> read/Write Lock으로 사용한다면 커버가능. 대신 로직굉장히 복잡해짐.

-----------------------------------------------------------------------

채팅서버 설계(싱글스레드)

여러개의 워커스레드가 하나의 싱글스레드로 JOP을 던짐.
이때 우리가만든 락프리큐를 활용한다.


-----------------------------------------------------------------------

Jop 설계

Jop역시 패킷처럼 Copy를 줄이기 위해 간략화하여 보내야 할것.

.......................................................................

1. Type 
Join, Msg, Leave(어떤 핸들러로 왔는가? 무슨일을해야 하는가?)

.......................................................................

2. 수행해야 할 대상(SessionID)

.......................................................................

3. PayLoad (추가데이터)

OnClientJoin핸들러로 받을때는 해당 클라IP등의 정보 등
Jop큐 구조체 인자로 필요한 정보(IP등)을 구조체에 추가한다.

해당 정보를 필요하지않는 타입인 경우 메모리낭비되지만,
유의미한 차이는 없음. (굳이 찝찝하다면 다른방법 강구)

.......................................................................

Jop생성

WorkerThread, AcceptThread가 Jop을 생성함

성능과 디버깅을 위해 JopPool을 사용(TlsFreeList사용)
당연히 모니터링이 가능해야함

-----------------------------------------------------------------------

싱글스레드 채팅서버

이후 채팅서버로 하나 더 만들어본다.
최대한 심플하게 만든다음, 나중에 멀티스레딩으로 바꿔봄.

이는 성능때문에 싱글스레드로 가는것이 아니라, 연습과정

-----------------------------------------------------------------------

멀티스레드 채팅서버

1. IOCP에 있는 WorkerThread들이 직접적으로 컨텐츠 처리

마음대로 각자 처리한다면 엉망진창됨
 -> 컨텐츠가 분리되어있다는 전제가 됨.
(겉으로는 통합이더라도 내부에서 어떻게든 분리)


2. IOCP WorkerThread들이 여러개의 UpdateThread로 처리

스레드가 여러개이므로 JopQ도 여러개로 나옴


(채팅서버 같은 경우는 1번이 낫다)

-----------------------------------------------------------------------

채팅서버 검증

채팅서버가 제대로 받아서 주변에 뿌리는것은 검증이 어려움
따라서 Recv / Send의 비율로 확인

서버입장에서는 Send가 많음
클라입장에서는 Recv가 많음

섹터하나당 한명씩인 경우 -> 8~9배정도 비율
섹터하나당 세명씩인 경우 -> 27~30배 정도가 나옴

-----------------------------------------------------------------------

IOCP - RunningThread조절

단순 1초에 한번씩 출력(IO작업)만 하는 Monitor를 포함시키는것은 아깝다
실제 우리서버외에도 다른프로세스에서 스레드가 돌기때문에,
일반적으로 코어에서 두세개정도 제외

-----------------------------------------------------------------------

UpdateThread가 깨어나는 방식

JopQ에 Jop이 들어왔을때 깨어나서 일을 해야함
Event방식, APC Q, IOCP등 여러가지 방법을 사용하여 깨울 수 있음

-----------------------------------------------------------------------

IOCP를 큐로 활용

PQCS로 Enqueue하고, GQCS로 깨어남.
UpdateThread가 1개이기 때문에 RunningThread가 1개이므로 의미 X

장점 : Event사용보다 깔끔해지고 신뢰할 수 있음
단점 : 내부 큐에대한 제어가 되지않음. NonPagedPool메모리 사용

-----------------------------------------------------------------------

큐 내부 모니터링이 필요한 상황

평소 10개정도 유지되다가 5,6만개로 올라간다면?
UpdateThread로직에서 개선. 안된다면 동접다운

이러한 사항들은 모니터링해야함

-----------------------------------------------------------------------

LockFreeQ를 쓰지않을 경우

우리는 LockFreeQ로 갈것이지만, 실무에서는 믿어주지않음
해당 구조에서 Q가 필요하고, 내구조를 활용하기 곤란하면 IOCP가 매우적합

-----------------------------------------------------------------------

UpdateThread의 Jop분기문(Switch)

.......................................................................

default로 들어온 경우

게임서버로부터 핸들링된 Jop을 타입별로 처리함.
서버문제이므로 클라를 끊어서는 안됨

강력한 로그를 남기고 Crash를 남겨야함
라이브서비스라면 고민..

.......................................................................

분기먼 개선 - 다형성(Command 패턴)

함수포인터, Switch - case문은 구시대적인 방식
대부분은 다형성을 이용하는 추세

다형성을 활용한다면 부모 Jop Object를 상속받아 타입별 Obj가 나옴
코드는 깔끔해지겠지만 Switch-case문에 비해 느려짐

.......................................................................

다형성의 경우 문제

다형성 적용하면 제일처음 JopQ의 타입이 최상위 Obj클래스 타입으로 바뀜

그런데 메모리풀은 Jop별로 나와야하므로, 핸들링타입이 추가될때마다
타입별 메모리풀이 추가되는 문제가있음

-----------------------------------------------------------------------

범용적인 메모리풀(malloc pool)설계

malloc과 같이 범용적인 메모리풀은 사이즈별로 할당이 필요
MS의 LFH(LowFragmentHeap : 저단편화 힙)처럼 다양한 버킷단위로 관리

규격별로 메모리풀을 만들어 각자가 관리. 
요청하는 사이즈에 가장가까운 규격덩어리를 뽑아줌

.......................................................................

재사용시 빈공간을 빠르게 찾아야 하므로, 규격별 포인터를 보관해야함
어떤 사이즈를 요청할지 알 수 없음

힙은 사이즈를 리스트로 연결하며 사용하므로, 
이를 해결하지못하면 기존힙이랑 다를게없음

.......................................................................

통용되는 heap

실제힙은 규격을 메모리주소로 정해놓지않고,
순차적으로 내려가면서 할당한다.

.......................................................................

범용적인 메모리풀(malloc Pool) 구현

사이즈별 메모리풀이 별도로 존재.
단편화를 없애고 재사용이 가능하게끔 하기위해서 규격을 맞춤

.......................................................................

MS의 LFH같은 경우도 bucket이 10개이상 존재하여 규격에 맞춰 뱉어줌

(규격을 상회하는 MB단위라면 VirtualAlloc()을 개별적으로,
페이지를 따로떼어 할당한다음 해제요청시 즉시 Free)

같은 규격을 반환후 재할당했을 때 같은 공간의 포인터를 빼줌

.......................................................................

범용 메모리풀의 공간을 확보할때는,

가상함수 테이블 및 생성자를 염두해야한다.
(malloc으로 크기만할당 할것인가, 더해서 placement new를 호출할 것인가)

-----------------------------------------------------------------------

직렬화버퍼 vs 구조체

직렬화버퍼를 사용한다면 Copy가 늘어나서 성능이 떨어짐
하지만 사용이 편리하기때문에 직렬화버퍼를 사용함

-----------------------------------------------------------------------

대부분 회사에서는 터지는 경우 감당이 안되기때문에
자체적으로 무언가를 쓰는 경우가 없음

-----------------------------------------------------------------------

다형성을 사용하는 경우

다형성을 사용해도, 타입별로 오브젝트 풀이 생긴다는것이 문제

역할도 다르고 크기가 다르기 때문이다.
따라서 단순히 가장 큰 타입의 메모리로 메모리풀을 사용한다면 해결

깔끔하지않지만 우리환경에서 메모리풀을 통합시키기 위해서는 방법X

-----------------------------------------------------------------------

로그인 서버

로그인서버는 서버에 접속하기이전에 검증을 위해 존재

통합회원정보 DB랑 연동하여 ID/PS와 접속할 서버를 확인하여 토큰 발급.
그리고 서버와 클라에게 토큰을 넘김.
클라는 해당토큰을 들고 가벼운 인증만을 거쳐 서버에 접속.

(토큰 : 유추할 수 없는 1회용 키 (64 ~ 128byte)

-----------------------------------------------------------------------

로그인서버의 존재의의

1. DB연동(회원정보 DB)의 부하를 줄임
2. ID/PS에 대한 노출문제


ID/PAS는 개인정보이므로 게임서버 프로토콜로 노출되는것은 절대금지.

비대칭키 RSA를 구현할 정도라면 가능함(리눅스나 안드로이드를 개발할수준)
만들었다고해도 느리기때문에 모든통신에서 사용불가

-----------------------------------------------------------------------

대칭키와 비대칭키 암호화

대칭키   - 인코딩/디코딩이 서로같은 암호화
비대칭키 - 인코딩/디코딩이 서로다른 암호화

NetServer - NetClient간 암호화는 대칭키암호화

-----------------------------------------------------------------------

RSA암호화 (비대칭키 암호화)

RSA암호화는 어마어마하게 큰 수를 대상으로 소인수 분해를 통해
브루트포스로 불가능한 시간이 나오게끔 만드는 암호화.

.......................................................................

비대칭키 암호화 표현 수

128암호화, 256암호화, 512암호화, 1024암호화
여기서 숫자는 비트크기를 뜻함 

64비트 표현범위만해도 1800경정도
1024비트의 경우 상상도 할 수 없는 수

이를 구현하고자 한다면 이 수를 표현할수있는 로직부터 만들어야함.
더군다나 수학적으로 접근하기 때문에 엄청나게 느리다.

.......................................................................

대칭키 - AES암호화 

표준인 AES암호화는 국방부에서도 사용할 정도로 신뢰성있음.
하지만 키가 외부로 노출된다는 위험성 존재.

노출조차 안되는 비대칭키가 가장 바람직하지만,
너무 느리기때문에 대부분은 대칭키-비대칭키를 섞어 사용함

-----------------------------------------------------------------------

https는?

키가 노출되는 것을 막기위해 키에대한 공유만 RSA암호화를 통하고,
그다음 송수신은 AES암호화로 전환한다.

-----------------------------------------------------------------------

로그인 서버를 웹으로 가는 경우

굳이 로그인서버가 직접짠 CPP서버로 존재할 이유는 없음

https로 안전하게 통신한 토큰을 발급받아 게임서버로 진입함.
토큰은 프로토콜로 노출되지만 1회용이므로 상관없음

-----------------------------------------------------------------------

오픈소스를 가져다 쓰는 경우

아파치나 웹서버같은 경우 오픈소스를 사용함.
오픈소스를 사용해도 상관없지만 이런걸 가져다 쓰는것조차 어려움

암호화가 필요한 서버를 직접만드는 것은 매우 위험

-----------------------------------------------------------------------

예제에서 진행할 로그인 서버

웹 로그인 서버를 통해 토큰을 얻을 수 있음
게임서버/클라는 토큰을 받음
클라가 가져온 토큰을 게임서버에서는 확인

로그인서버는 데이터를 유지할 필요없이 ID/PAS만 확인하면됨.
따라서 stateless로 간다. (여러대로 늘리는 것 가능)

-----------------------------------------------------------------------

서버에서 토큰 확인

클라는 토큰을 가지고 서버를 선택하여 서버에 연결.
서버는 클라토큰을 어떻게 검증할것인가?

-----------------------------------------------------------------------

토큰 검증

게임서버는 토큰을 검증하기위해서 일단 로그인서버로부터 토큰을 받아야함.

.......................................................................

1. 로그인서버가 모든 게임서버에게 해당 토큰을 뿌림 

단점 :  부담이 매우 큼 
.......................................................................

2. 유저 로그인후 어떤서버를 선택했는지 로그인서버에게 보내고,
로그인서버는 그서버한테만 토큰을 보냄

단점 : 로그인서버와 클라가 계속 연결을 물고있어야함.
(어차피 서버선택은 오래걸리지않으므로 큰문제는 아님)
.......................................................................

3. 유저 로그인후 어떤서버를 선택했는지 로그인서버에게 보내고,
게임서버가 로그인서버에 연결하여 토큰을 확인함

단점 : 로그인서버가 많아지는 경우 부담이 커지고, 언제까지 토큰을 
들고있어야 하는지에대한 문제가 있음

........................................................................

4. 별도의 토큰 서버 마련

다수의 로그인서버와 다수의 게임서버가 존재할때 어쩔수없이 오버헤드 일어남.
따라서 이를 체크하는 별도의 서버를 마련하는것이 가장 일반적임

-----------------------------------------------------------------------

토큰DB vs 토큰 서버

토큰DB는 DB연동에 대한 부담, DB자체도 매우 커지기 때문에 부하가 커질 것
(DB도 많이 사용되긴 한다)

-----------------------------------------------------------------------

토큰관리 결론

직접 서버를 만들거나, 메모리DB인 레디스를 활용하는것이 좋음.

레디스는 메모리DB(휘발성) 이기때문에 오히려 적합
인증이 끝난 토큰을 따로 보관할 필요가 없기 때문

-----------------------------------------------------------------------

레디스 사용


레디스는 관계지향형DB가 아닌 Key-Value이기 떄문에 맵이랑 비슷.

레디스는 모든 언어를 대상으로 모든 프로토콜 라이브러리가 만들어짐
따라서 웹에서 사용하기 편리함.
(대부분 로그인서버를 웹으로 감)

-----------------------------------------------------------------------

토큰서버 직접개발

웹이라는 환경에서 실제 TCP서버에 연결할 방법도 고민되어야함.

웹에서 소켓/포트를 열고 연결하는것이 불가능한것은 아니지만,
레디스가 굉장히 용이

-----------------------------------------------------------------------

Redis vs 직접만든 서버

레디스는 다양한 기능때문에 직접만든 서버에 비해 성능 떨어짐

문제터졌을 경우 내서버라면 독박씀. 
레디스로 가는 추세

-----------------------------------------------------------------------

실제 물리서버의 위치

토큰서버/로그인서버 모두 머신으로 따로 존재함을 가정
해당 컴퓨터 내부에는 MySQL, 또는 레디스같은 것들을 설치하고 감.

실제로 한 컴퓨터에 서버프로세스와 DB프로세스를 같이 올리는 경우는 없음
단, 사용자가 없다면 굳이 돈낭비를 할필요는 없음

-----------------------------------------------------------------------

중간 정리

1. 클라는 로그인서버와 커넥트하여 ID/PAS를 인증받아 토큰발급

2. 로그인서버는 토큰을 생성하여 토큰서버(또는 레디스)와, 클라한테 발급

3. 클라는 발급받은 토큰으로 인증을 거쳐 게임서버 접속

4. 게임서버는 토큰서버에 가서 토큰이 유효한지 확인
(게임서버가 토큰서버에 직접 접근하여 가져올 수있고, 요청할 수 있음)

-----------------------------------------------------------------------

메모리풀 - 가비지 컬렉터

할당 메모리를 일정시간 사용하지않을 경우 자동적으로 해제하는 기능

어차피 다시 사용될 확률이있으면, 굳이 해제를 할 필요가 있는가?
(이에대해 논문이 쓰여질정도로 수준이 높고 의견이 갈림)

-----------------------------------------------------------------------

가비지컬렉터 스레드 구현

사용자가 Free를 요청할 때 스레드를 깨운다면, 
오래쓰이지 않는 메모리는 해제되지 않음

-----------------------------------------------------------------------

타임아웃 기능

.......................................................................

네트워크 라이브러리에서 체크 vs 컨텐츠 쪽에서 체크


우리 라이브러리는 SessionArray가 필요할때 (반응이 있을때) 깨어남

하트비트 확인 시 해당세션에 IO유무를 알 수 없음
이 부분을 잘 테스트하여 검증해야함

-----------------------------------------------------------------------

채팅서버 프로토콜

REQ/RES로 방향성을 의미함. 서버간 통신은 SS
게임은 클라가 별다른 요청이 없어도 메시지를 보내는 경우가 많음

-----------------------------------------------------------------------

설정파일

빌드없이 간단히 설정을 바꿀수있게끔 해야함
실제 퍼블리싱을 받을 때, 아예 접근조차 하지못하는 경우도있음

.......................................................................

Bind IP

대부분은 0.0.0.0으로 갈것이지만, 만약을 위해 설정파일로 뺌.
이더넷을 여러개 설치하면 서버/클라가 나뉘어져 들어옴.

서버가 들어오는 별도의 환경이 구축된다면 분리되어야함.

현재 우리서버환경 또한 마찬가지임.
2U서버 컴퓨터에는 외부와 연결되어있는 라인10대로 private네트워크로 존재

.......................................................................

Monitor_No (모니터링 서버연동)

서버마다 고유번호를 부여해서 모니터링기준으로 삼아야 함.

.......................................................................

Packet Encode

인코딩 키 역시 설정파일로 빼는 경우 내부에서 파싱하여 넣어줘야한다.
(LanServer자체가 파싱의 주체가 되어서는 안됨)

.......................................................................

WorkerThread / RunningThread / MAX_CLIENT(동접) / Port

.......................................................................

SystemLog Level

어떤 로그로 진행할 것인지에 대한 로그레벨

.......................................................................

서비스에 해당하는 설정파일

TIMEOUT_DISCONNECT = 30000 (타임아웃 시간을 뜻함)

-----------------------------------------------------------------------


