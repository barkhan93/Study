손코딩 테스트

생성자, 복사생성자, 대입연산자, 덧셈연산자, 전위,후위연산자 손코딩.

----------------------------------------------------------------------------


매니지드와 네이티브 언어

매니지드

C#, JAVA, PHP등이 존재
프레임워크 위에서 돌아가는 스크립터언어를 말한다.
인터프리터 언어라고도 한다. 메모리를 직접 관리할수없다.


네이티브

C, C++ 등이 존재
직접 포인터를 다루고 메모리를 관리한다.
실제 컴파일시 어셈블리코드, 바이너리코드로 나오게된다.

----------------------------------------------------------------------------

inline키워드

특정 함수만 인라인하고 싶다면?
속도최대화를 끄고, 인라인키워드만 확장.

----------------------------------------------------------------------------

인라인의 단점

함수 Call자체가 사라져버리는것이므로 디버깅이 힘들다.
따라서 같은 소스코드를 2개 두고 최적화를 하지않은 코드로 디버깅

----------------------------------------------------------------------------

new

내부에서 Alloc, heapAlloc, virtualAlloc이 호출된다.
생성자를 호출해주는 코드가 new바로밑에 하드코딩된다.



delete
호출한 바로위쪽에 소멸자가 하드코딩된다.

이러한 하드코딩은 컴파일러가 해주는것이다.

----------------------------------------------------------------------------

메모리 확보시점

스코프안으로 들어오는 순간 메모리공간 확보는 끝이난다.
따라서 스코프가 몇겹이 있든간에 공간확보에는 아무런 영향이없다.

----------------------------------------------------------------------------

friend

friend void A::A_TestFunc() 와같이 사용이가능

----------------------------------------------------------------------------

virtual

부모포인터로 자식의 실객체를 담는것은 문제없음.
자식포인터로 부모의 실객체를 담는것은 불가능

가상함수는 포인팅형식이 아닌 실객체(오버라이딩) 함수를 Call한다

클래스 A - B - C 순으로 상속된다고 했을 때,

C객체가 생성될때, 

C - B - A / - B - C

부모생성자를 타고올라가서, 생성자를 호출해가며 가상함수 테이블을 매번 대입


----------------------------------------------------------------------------


가상함수 오류

앞쪽메모리가 오버플로우되어 가상함수 포인터를 침범할 수 있음

----------------------------------------------------------------------------

객체가 nullptr이더라도, 함수호출에는 문제가없음.


----------------------------------------------------------------------------

new/delete 오버로딩

void* operator new(size_t size)
void* operator new[](size_t size)

#define new new(__DATE__, __LINE__)
void* operator new (size_t size, char* File, int Line)
void* operator new[](size_t size, char* File, int Line)

----------------------------------------------------------------------------

new/delete 오버로딩으로 오류잡기

new[]할당, delete해제
소멸자가 한번만 호출 될 것이다.

new할당, delete[] 해제
쓰레기값에 접근하여, 쓰레기값만큼 소멸자를 호출시킬 것이다.

----------------------------------------------------------------------------

delete한 값은 내부적으로 0x08123으로 바꿔준다.

이값을 delete한다고 해서 안전한것은 아니다.

또한, nullptr를 delete하는경우는 내부에서 막아준다.



----------------------------------------------------------------------------

placement new

힙에서 메모리를 할당해오는 것이 아니라,
이미 할당된 메모리에 생성자호출 + 가상함수테이블 공간을 확보한다.

사용법

int* a = (int*)malloc(sizeof(int));
CTest* Test = new(a) CTest;




----------------------------------------------------------------------------

서버에서 별도의 힙을 만들어 쓰는것을 권장하는 이유

핸들링되지않는 에러가 발생시 힙이 깨지게되고 이 경우 덤프도 제대로 남지않음.
힙이 깨져서 API함수가 제대로 호출되지 않기 때문.

----------------------------------------------------------------------------

virtual 상속

사용법
class A  : virtual public B



	A

B1		B2
	C

순으로 상속이 되고있을때,


B1, B2에 virtual키워드를 붙이게되면 C는 A의멤버를 하나만 가질수있게된다. 
----------------------------------------------------------------------------

멀티스레드 환경에서 위험한 함수들이 존재한다.
주의할것.
ex) localtime -> localtime_s


localtime_s로 년월일시분초를 얻어올수있음.
(GetLocalTime()이 더 쓰기 용이한것같다)

----------------------------------------------------------------------------

덤프란?

레지스터, 콜스택, 메모리, 프로세스, 스레드정보 등이 저장되어있는 파일

----------------------------------------------------------------------------

힙이 깨지는경우 문제는?

1차적으로 동적할당/해제 부분이 정상적으로 작동하지않을 것이고,

덤프가 남지않기 때문에 디버깅이 굉장히 어려워진다.

----------------------------------------------------------------------------

템플릿

템플릿은 경우 컴파일시점에서 코드를 만들어내는 것이다.
C++를 별도로 나누지않고 헤더파일로만 작성한다.

----------------------------------------------------------------------------

최적화시 주의할점

느린것보다는 호출량이 많은 것을 우선순위로 두어야 한다.

프로파일링시 보통 몇억번의 호출기준으로 판단한다.

----------------------------------------------------------------------------

평균 계산시

평균을 계산할때 오차가 발생한다.
이것이 누적되면 나중에는 큰 오차를 발생시킬 것이므로,
최대한 잇는 그대로의 데이터를 가지고 최종적으로 평균을 내야한다.

데이터를 모두 보관하는 것이아니라, 합산만 해놓고 평균을 내는 것.

----------------------------------------------------------------------------

스코프를 열고 닫는것으로 객체 생성/소멸자 시점을 조절할 수있음.

----------------------------------------------------------------------------

Try - Catch 문

특징 : thorw는 있는데 Catch문이 없을 경우 프로세스가 즉시 죽게된다.

스택이 알아서 정리되므로 편리하지만 스택이 사라져버리므로 디버깅이 거의 불가능.
따라서 throw로 던질때 에러에 관한 정보를 모두 던지는데, 이때 예외객체를 만든다.


장단점

엔진또는 라이브러리를 만들때 좋은 사용처가 되지만, 사용자입장에서는 불편.
함수를 쓸때마다 catch로 예외를 받아줘야함.

여러함수를 모두 try를 묶을경우, 예외상황시 어디가 문제인지 파악 불가.


예외상황시 이미 프로그램이 정상적인 상황이 아니므로,
예외발생시의 부하를 걱정할 필요는 없음.
제한적으로 꼭 필요한곳에 사용하는 것을 권장


----------------------------------------------------------------------------

static의 순서

선언순서대로 생성, 역순으로 파괴된다고 명시되어있긴하나
표준이 아니므로 언제바뀔지 모름.
이에 의지해서 로직짜는것은 권장 X

----------------------------------------------------------------------------

싱글톤을 구현하는 방법

1. 전역함수 내에 static지역변수로 두는 방법

	- 사용하지않아도 메모리할당.
	- 파괴순서 보장 X -> 다른 전역변수가 사용할때 문제 가능성


2. 클래스 멤버변수에 static변수로 자기자신을 두는 방법
	
	- 사용하지않아도 메모리할당 및 초기화.
	- 파괴순서 보장 X -> 다른 전역변수가 사용할때 문제 가능성


3. GetInstance()호출시 동적할당하여 리턴하는 방법
4. 템플릿 싱글톤 클래스를 만들어 상속받아 쓰는 방법 

	- 3,4 공통문제
	- 파괴자 호출불가
	- 멀티스레딩 환경에서 문제.

----------------------------------------------------------------------------

atexit()함수

해당 프로세스가 종료될때 자동으로 호출되는 함수를 지정할 수있음.
단, 여러개를 저장할경우 순서보장이 어려울 수 있음. (static 소멸자와 순서같음)

----------------------------------------------------------------------------

디자인 패턴

Player, PlayerUI(플레이어 정보 필요), DB전송, 파일 등이 있다고 가정한다.


1. 폴링(polling)방식

UI쪽에서 직접 Player객체 접근하여 데이터를 가져옴


2. Event 방식

Player쪽 데이터가 변경 -> UI에 통지


3. 옵저버 패턴

한 객체의 상태가 바뀌면 의존객체 모두에게 연락이 간다. 
1대다(one - to- many)방식

Player객체를 참조하는 모든 객체를 Player객체 내부에두고,
Player내부 데이터가 변경될때 참조객체들을 순회하면서 갱신한다.

(ex 파티끼리의 채팅)


3-1. 옵저버 패턴 디자인 원칙

옵저버 패턴은 느슨한 결합(Loose Coupling)을 제공한다.
옵저버는 구상클래스가 무슨일을 하는지 알 필요가 없음(다형성 활용)

주체와 옵저버는 인터페이스만 들고있을뿐 서로에게 독립적이다.
주체나 옵저버가 바뀌어도 서로에게 영향 X
호출 순서에 의존하는 코드는 절대로 존재 X


4. 데코레이터 패턴

하나의 객체에 양념치듯 Attach하는 것
메인이 되는 클래스가 마치 리스트가 된 것처럼 attach된 객체들 끼리 
꼬리를 물고 연결이 된다.

아이템 옵션이 달라붙는 것을 이런식으로 처리하겠다는것은 절대금지


디자인 패턴 정리

프로젝트가 커질수록 디자인패턴보다는 절차지향이 훨씬 직관적이고
유지보수나 관리적인 측면에서 용이하다.
(단, 반복적인 요소나 불필요한 요소들이 추가될수는 있음)


5. 생산자 - 소비자패턴

예외로 대부분의 서버에서 사용하는 패턴이다.
소비자가 별도의 스레드로, 병렬로 분리되어있는 구조이다.
(ex 로그저장, DB저장 등...)

----------------------------------------------------------------------------

DB저장 시점

1. 플레이어가 로그아웃 할때 저장?

	- 서버가 죽으면 저장불가
	- 로그아웃 할때마다 저장하는것은 비효율적


2. 그렇다면 로그아웃시 변경 사항만 저장?

	- 단, 로그아웃할때 변경사항만 저장한다는 것은 구현 불가능. 
	- 하나하나 비교 -> 비효율적
	
3. 결론 : 실시간 저장

	- 이벤트가 있을때마다(아이템획득, 레벨상승) 저장하는 방식.
	- 스레드를 분리시켜 DB스레드한테만 Jop을 던지는 방식.
	- 100% 저장되어야 하므로, 인큐후에 피드백필요 X
	- 저장하다 오류난경우, 서버를 다운시켜야함

----------------------------------------------------------------------------

큐에 들어갈 Jop디자인

절차지향 - switch case등의 분기문 사용
객체지향 - 다형성을 이용해 command 패턴사용

----------------------------------------------------------------------------

command 패턴

요청을 객체형태로 만들어 처리하는 방식.
Jop Dequeue - 수신자객체로 형변환 - 가상함수 RUN

----------------------------------------------------------------------------
DB 라이브러리는 모두 동기화 형태이다.

----------------------------------------------------------------------------

Actor패턴 (ProActor, ReActor)


ReActor

생성자 - 소비자 패턴을 말함.
단순히 일감을 던지고, 그에관한 결과가 필요하지않은 경우

ProActor

우리가 사용하는 비동기 입출력을 뜻함. (ex IOCP)
일감을 받은쪽에서 수행이 완료되면 완료통지로서 전달해주는 패턴. 

----------------------------------------------------------------------------

전방 선언

클래스를 포인터형태로 가질때, 전방선언으로 include가 꼬이는상황을 막을수있다.

----------------------------------------------------------------------------

DOD (Data oriented desing)

직관성보다는 오로지 캐시히트율(성능)을 1순위로 두는것에 중점을 둔다.
플레이어 로직을 처리할때, 체력은 체력끼리 좌표는 좌표끼리 처리하는 형태.
콘솔쪽에서 종종사용하지만, 이렇게까지 하지않음

----------------------------------------------------------------------------

Cache hit

캐시라인 하나는 보통 64byte
캐시미스를 피하기위해 alignas가 존재한다.

하나의 데이터를 여러코어에서 사용할때, 값이 변경된다면 해당캐시를 무효화한다.
이때 캐시라인안에 변경되지 않은 데이터가 있어도 다시 가져오기때문에 성능저하.

자주변경되는 데이터와 읽기만 하는 데이터를 분리할 것.
이는 체감이 될정도로 성능차이가 존재한다.


----------------------------------------------------------------------------

게임과 객체지향

객체지향은 서로간 최대한 의존성이 없게끔 해야한다.
하지만 ㄴ게임은 서로간의 상호작용이 심하고, 처음 설계하지않은 새로운것들도 추가될 가능성이 있기때문에 적합하지않음.

----------------------------------------------------------------------------

객체지향 설계 - 오브젝트

최상단 부모 클래스
int x
int y
int ObjectType;

가상함수 설계 (다형성)
Action / Run(Update) / Draw(Render)

모든 오브젝트를 하나의 리스트를 관리한다. 그안에서 각자의 가상함수가 돈다.

오브젝트들의 성질에 맞게 리스트를 또 나누는방식은 객체지향과 어긋난다.
새로운 종류의 오브젝트를 만들어야한다면 오브젝트 리스트를 또 만들어야하기때문.



객체지향 설계 - 매니저

따로 클래스로 존재하지않고 생성/관리함수가 전역으로 있어도 상관없다.
객체지향에 가장 적합한것은 싱글톤으로 존재하는 것.

----------------------------------------------------------------------------

객체지향의 단점

다형성으로 상위클래스 포인터로 관리하다보니 실객체가 무엇인지 알기 힘들다.

----------------------------------------------------------------------------


main
{	
	씬매니저-> Run
}


씬매니저Run
{
	씬이 뭔지에 따라서 달라짐.
	씬->Run
}


씬Run
{
	씬초기화 및 준비 (오브젝트 매니저 생성)
	오브젝트 매니저->Run
	오브젝트 매니저->Render
	
	스크린오브젝트->Flip
}


오브젝트Run
{
	오브젝트 리스트순회 -> 오브젝트->Run
}


씬의 전환시 delete *this와 같은 문법을 사용할수도 있겠음.
전혀 문제없는 문법이다.

하지만 안전하게 별도의 변수를두고, 변수에따라 해당 씬의 함수가 돌아가게끔
하는것을 권장한다.



오브젝트 리스트 - 전역에 위치

 - 씬에 영향받지않고 객체관리 가능 (씬 전환시 객체보존) 
 - 다른객체 접근시 용이 

ex) 충돌 처리 시 전역 오브젝트 매니저에게 요청 (직접 순회하는것은 객체지향X)


오브젝트 리스트 - 씬안에 위치

 - 씬 생성, 파괴시 정리 수월
 - 씬을 넘나드는 객체설계 어려움
 - 객체가 다른객체를 검색이 어려움

ex) 충돌 처리 시 씬매니저한테 씬포인터를 요청 -> 게임씬을 찾아감
	-> 오브젝트 매니저 요청 -> 충돌 요청




----------------------------------------------------------------------------

----------------------------------------------------------------------------
