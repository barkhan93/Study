스핀락은 싱글코어에서 성능이 어떤가?

아무의미없음. 듀얼코어 이상에서만 사용할 것.

-------------------------------------------------------------------------

스핀락을 사용할때 가장 이상적인 경우는?

내 퀀텀타임 내에서 성공하는 경우.
더길게 잡고간다면 블락되는게 차라리 나을 수 있음

-------------------------------------------------------------------------

유저모드객체에 요즘 내장하는 것은?

스핀락. 일정회수 시도해보고 블락걸리러 간다.

-------------------------------------------------------------------------

yeildProcessor는?

스레드를 놓아주는것이 아님. 계속 Running상태.
대신 하이퍼스레딩에서 현재 스레드를 실행시키는 코어를 한번쉬게끔함.

-------------------------------------------------------------------------

피터슨 알고리즘이란?

인터락 함수를 쓰지않고 단순히 flag체크하여 두개의 공간을 두고,
두개의 스레드가 서로 안전하게 진입하는것을 목표로 삼은 알고리즘

-------------------------------------------------------------------------

피터슨알고리즘vs동기화객체

동기화객체는 어떤스레드든 독점접근하여 사용하겠다는것.
스레드 두개만을 넣고 바꿔가며 돌아가는것이 아님

-------------------------------------------------------------------------

스핀락은 주로 어디서 사용되는가?

OS내부 커널에서.

-------------------------------------------------------------------------

락프리 vs 스핀락

스핀락은 접근을 목적으로 하는 기다림
락프리는 최종commit에 대한 확인. (일단출발)

-------------------------------------------------------------------------

락프리는 어떤형태로 구현되는가. 이유는?

싱글리스트 형태. 포인터를 바꾸는것으로 commit되야함.
배열(push, 인덱스변경), 더블리스트(prev, next)는 두가지가
동시에 변경해야하므로 불가능

-------------------------------------------------------------------------

락프리를 구현하는데 있어 반드시 지원되어야 하는 기능은?

DCAS(인터락128)

-------------------------------------------------------------------------

락프리큐는 어떤방식으로 구현되나?

1. head, tail을 더미로 둔다
인큐하면 tail의 앞노드를 찾을 수가 없음

2. head, tail을 포인터로 둔다
head와 tail을 동시에 바꿔줘야하는 상황때문에 불가

3. head에만 노드를 둔다
인큐시 head와 tail을 동시에 바꿔줘야함. 불가.

4. 처음 더미를두고, 내 노드를 더미로 계속사용
한박자 늦은 해제하는 느낌

-------------------------------------------------------------------------

락프리스택 메모리풀의 통합은 성능상 어떨까

각자가 가지고있는것보다 메모리를 효율적으로 사용할 수 있을것

-------------------------------------------------------------------------

구현은 어떻게?

스택은 템플릿안에 템플릿스태틱을 넣는 방식으로 구현.
큐는 인큐시 nullptr만 확인하고 인큐하므로 통합불가.

-------------------------------------------------------------------------

락프리 vs 동기화객체

서버에 적용해보니 오히려 거의 차이가 없거나 락프리가 더 느리다.


-------------------------------------------------------------------------

인터락 10번 vs 동기화객체걸고 10번연산후 해제

후자가 높을 가능성이높음.
후자가 캐시히트율이 100%이기 때문

-------------------------------------------------------------------------

랜서버에서 Disconnect는 어떻게 해결?

서로가 양보하는모양.
재할당은 IOCount증가이후, SessionID 비교로 완벽하게막음

-------------------------------------------------------------------------

TLS란?

스레드 로컬 스토리지. 스레드에 처음부터 붙어있는 저장소.
OS차원에서 기능을 제공해야만 사용가능.

-------------------------------------------------------------------------

동적TLS와 정적TLS의 차이는?

동적TLS는 API차원에서의 기능. 한계존재
정적TLS는 컴파일러 차원에서의 기능. 한계없음

동적TLS는 이미 만들어져있고, 정적TLS는 요청하는 경우 만들어준다.

-------------------------------------------------------------------------

정적TLS의 단점은?

컴파일러가 정적TLS변수를 참조하기위한 추가코드생성.
어플리케이션 볼륨증가, 속도 하락.

x86 CPU에서는 하나의 정적TLS변수를 참조할때마다 세개의 기계어
명령어가 추가됨

-------------------------------------------------------------------------

동적 TLS의 단점은?

함수호출로 사용해야하기때문에.. 성능에는 큰 차이없음.

-------------------------------------------------------------------------

동적TLS의 특징은?

최초접근시 0으로 초기화되어있다는점.
접근할 데이터 유무를 판단하는 중요한 요소.

-------------------------------------------------------------------------

각자의 TLS메모리풀 구현은 어떤가?

A스레드에서 Alloc한것을 B스레드에서 Free할수있다.
따라서 문제.

-------------------------------------------------------------------------

TLS메모리풀의 동작방식은?

요청시 요청스레드의 TLS를 뒤져 n개만큼 할당한다음 1개를 뱉음.
반납하면 카운트올림. n개만큼 반납되면 메모리풀에 반납.

-------------------------------------------------------------------------

프리리스트없이 단일로 락프리 구현이 안되는이유
락프리 로직순서(Unique, 노드대입)