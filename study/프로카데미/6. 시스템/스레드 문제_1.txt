기아현상 해결법은?

에이징기법(시스템부하가 많아 오래기다린 스레드의 우선순위를 높여줌

---------------------------------------------------------------------

스레드가 깨어날떄 OS는 어떻게?

OS가 우선순위 상승시킴

---------------------------------------------------------------------

블락된 스레드가 많아지면 성능은?

리소스는 많이먹겠지만 성능에지장x

---------------------------------------------------------------------

타임슬라이스는 왜 보통 다쓰지못하나?

I/O작업이 대부분이기때문.
따라서 코어보다 스레드를 많이만들어 성능향상을 노리는 이유이기도함.

---------------------------------------------------------------------

SysCall이란?

커널모드 전환을 일컬으며, 이역시 인터럽트이다.

---------------------------------------------------------------------

디스패쳐는 뭔가?

타임슬라이스를 다썼다고 판단되면 스케쥴러를 통해 스레드들의 상태변경을 해주는 인터럽트.

---------------------------------------------------------------------

커널패닉

인터럽트 핸들러에서 해서는 안될것을 하거나, 시간을 많이 소비하는 등의문제
현재 MS에서는 이런경우 X.

---------------------------------------------------------------------

쓰레드관리는 뭐로하고있나?

커널에서 하므로.. 스핀락쓰거나 락프리형태로 되어있음.
커널내부에서는 실행단위가 너무작기때문에 락을 걸지않음.

---------------------------------------------------------------------

Sleep(1), Sleep(0), yeildProcessor()

Sleep(1) - 블락되어 1m/s만큼 쉬었다가 다시 레디큐맨뒤로 들어감
Sleep(0) - 블락되지않고 즉시 레디큐 맨뒤로 들어감
yeildProcessor() - 다른스레드에게 기회를주지만 OS입장에서는 하나의스레드

---------------------------------------------------------------------

인터럽트는 수시로발생한다. 예로 뭐가있는가.

네트워크 송수신, 파일입출력, 키보드입력 등..

--------------------------------------------------------------------

atomic연산중 유의해야할 것은?

캐시라인에 틀어졌다면 atomic연산이 보장되지않음.

--------------------------------------------------------------------

pseduo 핸들이란?

가짜핸들.
진짜 핸들을 복사하기위해서는 DuplicatedHandle등 복잡한 과정을 거침
UC증가, 프로세스 핸들테이블에 추가 등..
따라서 자기자신을 가리키는 가상핸들을 두는것.

--------------------------------------------------------------------

endThredex는 런타임Lib에서 제공하는데 왜쓰면안됨?

지역객체 소멸자는 해당함수 자체에 하드코딩됨.
따라서 동적으로 스레드종료/프로세스 종료는 금지.

--------------------------------------------------------------------

동기화객체 CS의 성능에 대해 서술.

동기화 걸리지않으면 인터락과 성능 비슷. 인터락 비트체크.
동기화객체가 많다고하여 큰 성능저하 X
동기화이슈가 많이 생긴다 성능저하O

--------------------------------------------------------------------

스핀락이 가장 성능이점을 보는 시점은?

타임슬라이스가 끝나 컨텍스트스위칭 되기전에 성공한다면 
가장큰 성공이점.

동기화까지 안가도되니까.

--------------------------------------------------------------------

하이퍼스레딩이란

CPU가 물리적으로는 하나지만 논리적으로 두개인 형태.
캐시므스 등으로인한 CPU여유가 생길때 번갈아가며 시도하는것

두개의 스레드를 처리함. 30%정도의 성능향상 기대가능.

--------------------------------------------------------------------

SpinLock을돌때 요즘들어가는 명령어는?

yeildprocessor(pause)
혼자 점유율을 모두 차지하지않고 다른쪽 코어에 한번씩 기회를줌

--------------------------------------------------------------------

뮤텍스 특징

서로다른 프로세스에서 접근이 가능.

--------------------------------------------------------------------

방향성이 있다면 동기화객체 사용안해도됨.

--------------------------------------------------------------------

스레드입장과 동기화객체 입장에서 시그널/논시그널 설명

스레드 시그널 - 스레드가 실행중
스레드 논시그널 - 스레드 블락

동기화객체 시그널 - 이벤트객체를 기다리는 스레드 종료(끝남)
동기화객체 논시그널 - 이벤트객체를 기다리는 스레드 실행중(안끝남)

--------------------------------------------------------------------

Out-of-ordering이란?

CPU가 캐시미스 등으로 할일이없을때 단순히 쉬지않고 명령어를 재배치하여
좀더 효율적으로 돌게 하는것.

--------------------------------------------------------------------

분기예측은?

실행될 조건문이 어떤곳으로 분기할것인지 미리 추측.
성공한다면 성능향상, 실패하면 하던대로 돌아감.

--------------------------------------------------------------------

인터락 vs OutOforder

명령어재배치를 막는 메모리펜스보다 인터락이 더빠르므로 사용.

--------------------------------------------------------------------

x86아키텍처에서 가능한 리오더링은?

로드뒤로 로드 리오더 불가
로드뒤로 스토어 리오더 가능

스토어뒤로 로드 리오더 불가
스토어뒤로 스토어 리오더불가

--------------------------------------------------------------------

Lfenc + Sfenc 가 mfence랑 같지않은 이유는?


Lfence를 했더라도 아래 전체가 올라갈 수 있음
Lfence는 코드순서를 바꾸지않기때문에 의미X

그래서 컴파일러는 Lfence를 쓰지않음.

mfence는 해당기점으로 위아래를 절대섞지않는 베리어.

--------------------------------------------------------------------

피터슨 알고리즘이란?

동기화객체없이 멀티스레드 로직이 돌아가는 알고리즘.
OOO로 정상작동되지않음.

그리고 동기화의 개념이란 일이없을때 기다리는것이지,
무조건 두개의 로직이 같이도는 개념이 아님.

--------------------------------------------------------------------

속도를 빠르게하기위해 택하는방법은?

사본을 만들어두고 사용하는것.

--------------------------------------------------------------------

멀티스레드환경에서 성능측정이란?

1. 코드(블럭)의 수행시간
2. 초당 처리회수
3. 서버-클라간 응답속도

--------------------------------------------------------------------

읽기 비동기가 어려운 경우

읽는다는것은 지금당장 데이터가 필요해서 읽는건데...
이걸 보류하고 다른일을 하게끔 설계하는것이 쉽지않음.

--------------------------------------------------------------------

시간에 따른 컨텐츠구현 TimeThread는 어떤가?

메시지던질때 카피1, 뽑을때 카피2, Proc로직처리,
Event에서 쌓이는양, TimeThread와 UpdateThread간의 동기화 등의 오버헤드
로 인해 성능이 매우 좋지않다.

--------------------------------------------------------------------

DB커넥트는 어떻게처리?

DB와 커넥트하는 스레드는 성능상 따로빼는게 나음. 매우느리기 때문

--------------------------------------------------------------------

게임서버 성능이라함은 무엇이있는가?

1. 코드차원에서 성능
2, DB저장능력(DB가 못버티면 동접자 낮춰야함)
3. 네트워크 트래픽

--------------------------------------------------------------------

7.8과제 어떤에러가 어떻게 나는지 공부해오기

--------------------------------------------------------------------

WaitForMultipleObjects시 주의점

중요한 Event의 signal일수록 배열앞쪽에 배치할 것.
빈번하게 signal되는 Event가 앞쪽에 배치되면 체크조차 못함.

--------------------------------------------------------------------

서버를 컨텐츠단위로 스레드분리시 문제는?

유저가 컨텐츠를 넘나들때 스레드간 이동에 동기화이슈가 발생.
데드락위험도 있음.

--------------------------------------------------------------------

해결책은?

A->B스레드로 이동시 A에게 요청하게끔 함.
별도 매개체를 두고 매개체와 B에만 락을건다. A에는 락 X

A에서 유저빼고, 매개체와 B를 락걸고 큐잉.

--------------------------------------------------------------------

이 설계의 단점은?

코어가 늘어나도 성능이 비례하여 늘어나지않음.(헤테로의 본질적인문제)
유저 분포도 불균형(유저들이 필드에만 있다면 싱글스레드나 다름없음)

--------------------------------------------------------------------

동적할당 메모리를 잘못사용하면 에러는 어떻게남?

해제할때 heap이 예외를 발생시킴.

--------------------------------------------------------------------


