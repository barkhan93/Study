선점형   - 커널스레드 (선점가능)
비선점형 - 유저스레드 (끝날때까지 선점불가)

---------------------------------------------------------------------

유저스레드

어떤 OS든 유저스레드(기능)가 내장되어있음.

유저스레드는 병렬수행이 아닌 병렬흉내를 내는것이므로 쓸대상 X

---------------------------------------------------------------------

스레드

자신의 Call stack과 CPU상태를 갖는 소프트웨어 수행경로
윈도우는 스레드가 코드의 수행단위이며 핵심.

스레드는 프로세스 안에서 자신만의 스택을 가지고 운영체제에 의해 
스케쥴링되는 CPU시간을 할당받는 실행의 단위

스레드를 더 많이가진 프로세스가 더 많이 돈다.
(스레드간 스케쥴링)

---------------------------------------------------------------------

코드와 데이터는 하나로 존재.

프로세스 기준으로 가상메모리 테이블이 존재.

가상메모리 테이블안에 코드와 데이터가 전역적으로 하나가 존재.

---------------------------------------------------------------------

레지스터 

CPU상태는 결국 모든 코드를 어셈블리로 받는 것
CPU가 코드를 처리한다는 것은 레지스터 기준
스택, 실행위치, 가상메모리 테이블 모든것이 레지스터에 있음.

CPU에 들어있는 레지스터 상태 = 스레드 상태

---------------------------------------------------------------------

스케줄러

컨텍스트 스위칭을 시키는 주체로서, 타이머 인터럽트를통해 수행된다

관리목적인 매니저느낌 X

---------------------------------------------------------------------

컨텍스트 스위칭

특정 스레드가 컨텍스트 스위칭되어 코어를 잡고 돌기 시작한다면
돌고있는 모든 레지스터를 CPU에 반영시키는 것이다.

(코드영역, 백업포인터, 스택위치, 가상함수 테이블, 연산위치 등...)


컨텍스트 스위칭이란 결국 CPU레지스터 상태를 온전히 백업/복구 시키는 작업

---------------------------------------------------------------------

인터럽트

CPU자체에 인터럽트를 받아들일수 있는 공간이 존재.
하드웨어를 꽂으면 무조건 인터럽트를 부여해야 한다.

특정 하드웨어가 인터럽트 신호를 보낸다면 CPU수행이 중지되고
해당 인터럽트에 대한 Proc가 호출된다. (이는 컨텍스트 스위칭X)

---------------------------------------------------------------------

인터럽트로 인한 레지스터 사용

최대한 레지스터를 사용하지않을 것이나, 썼다면 내부에서 백업하고 복원해줌.
이는 인터럽트 신호가 발생한 핸들러에서 알아서 한다.

---------------------------------------------------------------------

Syscall (커널모드 전환)

사용자모드가 커널영역의 기능을 사용하도록 도와주는 기능

Syscall역시 인터럽트로 실행된다.
커널에 있는 특정 코드를 수행하기 위해 인터럽트 번호를 꽂아넣고,
커널모드 전환 후 인터럽트 신호를 받아서 수행되는 구조이다

---------------------------------------------------------------------

타이머 인터럽트

메인보드 하드웨어 차원에서 인터럽트를 주기적으로 쏜다.
이를 기준으로 시간을 갱신한다.

발생주기가 낮을수록 더 정교하게 돌것이다.

서버에서는 timebeginperiod(1)로 가는것을 기본으로 한다.

---------------------------------------------------------------------

디스패쳐 인터럽트

타임슬라이스를 모두 썼으면 디스패쳐인터럽트를 발생시켜,
Running상태이던 쓰레드를 빼고 어느쪽 ReadyQ로 들어갈지 결정하여 넣음.

---------------------------------------------------------------------

스레드 컨텍스트 스위칭 (C.S)

같은 프로세스에 있는 스레드 C.S > 다른 프로세스에 있는 스레드 C.S

가상메모리 테이블(프로세스 별)로 인한 캐시히트율 차이.

---------------------------------------------------------------------

커널 패닉

어떤드라이버 인터럽트 핸들러에서 해서는 안될것들을 하거나,
해당 프로시져에서 너무많은 시간을 소비하는 등의 상황을 뜻한다.

현재는 MS에서 드라이버 코드를 모두 검증하여, 문제없는것만 허용


---------------------------------------------------------------------

ReadyQ

모든 코어에는 ReadyQ가 존재하며, 우선순위별로 스레 관리.
내부에서는 스핀락/락프리형태로 되어있음.


---------------------------------------------------------------------

현재 ReadyQ

윈10부터는 코어별로 존재한 레디큐가 그룹단위로 바뀌게되었다.

코어가 배정된 스레드는 다른코어에 여유가 있어도 기다리는 비효율적인구조
를 개선하기 위함.

코어를 그룹으로 묶어 CPU전체 코어개수에 비례하게 그룹이 잡히는 형태.
ReadyQ가 해당 그룹단위안에서 코어에 들어갈 수 있는 모양으로 변경됨.

---------------------------------------------------------------------

OS커널에서의 행위

커널내부에서는 로직처리의 볼륨이 작기때문에 락을거는 행위가 없다.
대부분이 스핀락/락프리로 이루어져있다.


--------------------------------------------------------------------

디스패쳐 인터럽트의 코어배정

돌고있떤 코어가 아닌 전혀다른 코어ReadyQ에 넣어버렸다면,
캐시미스가 날 것이고 이는 성능하락으로 이어짐.

---------------------------------------------------------------------

CPU 선호도

MS에서 공개한바에 따르면,
모든스레드는 CPU에 대한 번호가 존재하며
우리도 이 번호(선호도)를 API함수로 지정할 수 있다.

즉 선호도라는것은 한번 배정받은 곳에서 거의 무조건 깨어나야만 함.

하지만 문서와는 다르게 실제로는 이렇게 돌지않으며,
더이상 공개된 바가 없음.

---------------------------------------------------------------------

CPU선호도 지정

코어개수보다 스레드가 적거나 같을때, 선호도 지정으로 성능향상을 볼수있음.
코어개수보다 스레드가 훨씬많다면 이득보기 어렵다.

게임서버환경은 스레드가 훨씬더 많을 것.


---------------------------------------------------------------------

기아현상

우선순위가 높은 스레드로인해 다른스레드가 돌지못함

MS의 밸런스셋 매니저는 CPU ReadyQ에 있는 스레드중 4초이상 대기중인
스레드들에 대해 우선순위를 높여주는 방식으로 방안을 찾는다.

단, ReadyQ를 모두 뒤질수는 없으므로 열몇개의 단위로 검사.

---------------------------------------------------------------------

하이퍼 스레딩

코어는 하나이지만 파이프라인 구조상 비는공간이 생기거나,
캐시 미스가 나는경우 다른일을 할수있게끔 기능한다.

듀얼코어를 표방하지만 실제 듀얼코어와는 성능차이가 난다.

---------------------------------------------------------------------


멀티 스레드

[수행시간, 사용자 응답성, 프로그램 구조]중 하나를 만족해야 권장.

대부분이 빠른 수행시간(병렬처리)를 위해 멀티스레딩을 한다.

---------------------------------------------------------------------

멀티스레드 - 프로그램 구조 간결

WinMain을 예로, WinMain메인스레드는 윈도우 메시지처리,
게임로직은 별도의 스레드로 돌리는 형태.

또는 모니터링을 위한 출력(printf)같은 경우 스레드로 분리 가능.

---------------------------------------------------------------------

멀티스레드 - 사용자 응답성

비동기처리를 유도시켜 block되는 상태를 막기위함.

Connect를 blockSocket으로 호출할때 block되면 서버가 멈춘다.
이때 Connect를 다른스레드로 빼서 결과 피드백을 전달 받는다면,
사용자 입장에서 피드백이 있기때문에 이상함을 느끼지않음.

---------------------------------------------------------------------

수행시간 감소(병렬화 증가)

병렬화 구조로 수행시간을 감소시켜 성능향상을 노리는것이 주목적.
단, 여러개의 작업이 모두 공용자원을 사용하여 동기화가 걸린다면 의미X

---------------------------------------------------------------------

안정성 향상

1. 스레드에서 문제가 생기는 경우 덤프빼고 스레드중지.

호모지니어스 환경을 가정할때, 여러 스레드가 같은 범주의 일을 하지만
모두가 같은일을 하는것은 아니므로 해당문제를 만나는 스레드만 죽게 됨 
(특정기능만 문제)


2. A스레드가 멈췄을때 다른스레드를 가동시키자는 의미.
하지만 멈춘다는것은 데드락이나 무한루프의 경우이므로 프로세스 자체가죽음.

따라서 프로세스 단위로 보는게 맞다.

---------------------------------------------------------------------

물리서버 Active-Standby

가용성을 위해 Active서버가 죽으면 Standby서버를 즉시 가동하게끔한다.
이는 물리적으로 두대의 서버를 들고 가겠다는 의미이다.

---------------------------------------------------------------------

프로세스 Active - Standby

프로세스의 크래시, 오류를 대비해 하나의 프로세스를 더 준비.
하지만 둘은 완전히 같은 코드이므로, 큰의미가 없음.

---------------------------------------------------------------------


멀티스레드 설계

1. 똑같은 일을 하는 스레드를 여러개 만듬.
2. 스레드를 기능별로 분리함.

보통 MMO게임의 경우 유저간의 상호작용이 매우많아 멀티스레딩이 난해

---------------------------------------------------------------------

어쩔수없이 block걸려야 하는 경우

1. 키보드 입력(block)
	-> 키보드입력 / Recv를 따로처리하면 될 것.


2. 파일 입출력
	-> 파일읽기는 매우 느리기때문에 로딩스레드를 따로 만듬.

---------------------------------------------------------------------

퍼블리셔 쪽에서 서버가죽으면 다시 실행되게 해달라는 요구를 하기도함.

이때는 클라쪽에서 특정 작업을 거쳐 바로 Connect하므로, 사용자 입장에서는
잠깐의 렉이 있었던 것으로 느끼고 넘어간다.

별로 좋은 선택은 아님.

---------------------------------------------------------------------

Dump

예외가 생겼을때 레지스터, 메모리등을 복사하여 따로 파일로 빼는것.

현재는 vs가 좋아져 PDB파일만 존재한다면 실제 디버깅하는것처럼 환경제공

---------------------------------------------------------------------

WinDbg

Ms에서 제공하는 디버깅 프로그램.

텍스트명령어로 하나씩 보내야 하기때문에 불편
pdb와 exe가 맵핑이 되지않은 경우 억지로 메모리에 올려 텍스트로 볼때사용

현재는 잘 사용하지않는다.
(스택이 깨지는 경우 레지스터와 디스어셈블러에 의지하여 판단)

---------------------------------------------------------------------

스레드를 사용하면 안되는 경우

1. 두개의 스레드가 명확하게 독립적이지 않은 경우.
2. 발생하는 오버헤드가 실제 작업보다 더 큰 경우 
(구조간결이라면 시도해볼만 함직함)

---------------------------------------------------------------------

스레드 동기화 이슈

언어차원에서는 단순한 변수++이 어셈블리 입장에서는 다르기 때문에 안전X

어셈블리 내부 repeater일 경우 도중 OS가 개입하면 반복이 중단됨.

mov, cmp, lea와같은 일반명령어들은 CPU가 처리하는 최소단위
(컨텍스트 스위칭 불가)

---------------------------------------------------------------------

동기화(락)

내 스레드를 block시키고, 해당 동기화객체 signal이 올때까지 기다림.
내가 진입하고 다른스레드는 들어오지 못하도록 막는것이므로,
컨텍스트 스위칭유도되는 것.

---------------------------------------------------------------------

CreateThread

윈도우에서 스레드를 만들수있는 원초적인 API함수
메모리할당은 VirtualAlloc, 파일오픈은 CreateFile

단, 이경우 CRL이 알아차리지 못하기때문에 이 함수는 권장X
현재 이 함수를 사용해도 에러는나지않지만, 권장사항은 아님

---------------------------------------------------------------------

beginthreadex, Cppthread

내부에서 CreateThread하는 것으로, 플랫폼에 맞춰 랩핑한 것.

---------------------------------------------------------------------

프로세스

프로세스는 정보를 보관해주는 구조체로, 스레드가 실행되는 환경제공

프로세스는 메인스레드가 종료되면 종료된다.

---------------------------------------------------------------------

Stack

전역변수는 당연히 공유되고, 스택도 역시 같은 가상메모리 
테이블에 있으므로 공유된다.

스택메모리는 같은 가상메모리 안에서 구역을 나눈것일 뿐,
스레드별로 완벽하게 독립적인 구조가 아니다.

---------------------------------------------------------------------

우선순위

스레드가 타임슬라이스 할당량을 모두 사용하거나,
어떤 상황에 의해 block 당하는 경우 레디상태인 다음 스레드 수행

우선순위는 프로세스와 스레드의 우선순위를 합산하여 결정
우선순위가 높은 프로세스 또는 스레드를 최우선으로 결정

---------------------------------------------------------------------

작업관리자 우선순위

작언관리자에서 우선순위를 변경할 수 있다.

만약 우선순위가 높은 프로세스가 CPU 100%를 점유하고있다면,
우선순위가 낮은 프로세스는 전혀 실행될 수 없다.

---------------------------------------------------------------------

타임슬라이스(퀀텀타임) 수치

OS마다 복잡한 공식을 토대로 산출되므로 상수로 표현 X
(보통은 15m/s ~ 20m/s)

윈도우 서버OS는 타임슬라이스가 일반 클라보다 2배 길다.
(Windows Server 라는 OS 상품이름)

인터럽트로 발생된 시간은 타임슬라이스에 반영되지않는다.

---------------------------------------------------------------------

타임슬라이스 실제 동작

작업관리자에서 스레드가 수천개가 돌고있음을 확인할 수 있는데,
이에 반해 타임슬라이스는 꽤 긴 시간을 차지한다.

거의 대부분의 작업이 I/O작업에 들어가므로 퀀텀타임을 다쓰는 경우없음.

---------------------------------------------------------------------

스레드의 개수

일반적인 IOCP를 사용한다고 하면 기본적으로 열댓개의 스레드,
기능별 로직과 DB저장까지 염두한다면 2~30개 정도의 스레드가 나온다.

-----------------------------------------------------------------

프로세스 / 스레드 우선순위

우선순위를 건드리는것은 개발자 마다 다르므로, 향후 
회사정책이나 사수를 따라간다.


1. 찬성입장 

CPU가 부담이될때 중요한 스레드의 우선순위를 높여 로직을 돌게끔 함.

2. 우선순위 반대 입장

CPU가 부담이 되어 특정부분의 우선순위를 높인다는것은 이미 밸런스깨짐.
스레드를 설계하는데 덜중요하거나 더 중요한것은 없음.

---------------------------------------------------------------------

시스템이 우선순위를 변경하는 경우

특정 윈도우창 활성화 

---------------------------------------------------------------------

우선순위가 자체적으로 변경되는 경우

block당한 스레드가 signal을 받아 깨어날때 일시적으로 우선순이가 상승.

(우리가 서버에 사용하는 스레드만 우선순위를 다같이 높인다면 어떨까?)

---------------------------------------------------------------------

Blocked Thread가 성능에 미치는 영향

블락된 스레드는 시스템성능에 영향 X
ReadyQ에 몇개의 스레드가 들어있든 성능에 영향 X

큐 형태로 대기하는 스레드는 하나만 신경쓰고있음.

Sleep역시 몇개의 스레드가 Sleep되든, 긴시간 Sleep을 시키든
가장 빨리 깨어날 스레드만 보는것이기 때문에 성능과 관계 X

---------------------------------------------------------------------

Atomic Operation

최소단위 연산을뜻하며, atomic operation은 인터럽트 될수없는 연산의미

인터럽트 발생은 수행되는 명령어에 대해 비동기적으로 발생하는데,
cmp, jmp, mov, lea같은 최소단위 연산은 중단이 불가능하다.

명령어 repeater같은 경우는 CPU차원에서 반복문이므로 중단 가능.

---------------------------------------------------------------------

구조체끼리 대입할때 유의

구조체끼리 대입할때 64비트크기일 경우 repter mov, byte ptr로
byte단위로 카피하는 코드가 만들어진다.

이를 다른쪽에서 변수를 얻게된다면 안전하지않음

---------------------------------------------------------------------

Cache Line 중간에 걸쳐지는 경우

명령어 차원에서 최소단위여도, 메모리를 긁어오는 행위는 두단계.
캐시라인이 틀어졌을 경우 API차원에서 보장하는 atmoic이 보장되지않음.

---------------------------------------------------------------------

std::atomic (class)

정수형/포인터 타입에 대해 산술연산을 atomic하게 수행하게끔 하는 클래스.

C++11에서 표준으로 들어왔으며, volatile변수와 Interlocekd계열 함수를
일일히 사용하는 번거로움을 없앨 수있다.

내부적으로 Interlocked함수로 랩핑되어 있음)


---------------------------------------------------------------------


Mutex

커널모드 동기화객체.

C++에 std::mutex가 생겼다.
내부에서 SRWLock을 쓰면서 스레드를 확인하는 개념을 넣었다.
내부는 크리티컬 섹션과 흡사하다.

---------------------------------------------------------------------

DeadLock

서로 원하는 리소스가 상대방에게 할당되어 있기 때문에, 
두 프로세스가 무한정 기다리는 상태를 뜻한다.

데드락은 크래시가 나는것이 아니므로 알아차리기 힘들 수 있다.
따로 데드락을 위한 모니터링 방법이 존재하지 않기때문에,
하트비트 같은 방법을 사용한다.

디버깅(스레드)를 활용한다면 누가 락을 걸었는지 쉽게찾을 수있음.

---------------------------------------------------------------------

Thread Life Cycle 

1. CreateThread로 스레드 커널오브젝트가 생성 
(mainThread는 프로세스 시작시)

2. OS가 스레드의 커널오브젝트 초기화
(스레드 스택할당, TCB 구조를 생성하는 작업 포함)

3. 새로운 스레드의 시작Proc에 수행을 시작
4, 스레드 수행
5. 스레드가 종료코드와 함께 종료
6. 스레드의 종료코드가 스레드 커널객체에 저장되고, UC카운트 감소.

---------------------------------------------------------------------

UC카운트에 대해서

스레드 생성 후 closehandle로 생성하자마자 핸들을 반환하는 경우가있음.

이는 스레드를 종료시키는 것이 아니라 UC를 미리 차감하여 진행하는 것.
우리는 스레드에 대한 상태를 확인해야 하기 때문에 보관한다.

---------------------------------------------------------------------

스레드 생성

모든 스레드 생성함수는 수행을 시작할 지점에 대항하는 함수 포인터를 얻음.
이함수를 thread Entry Procedure라고 부른다.

DWORD WINAPI ThreadStartFunc(LPVOID lpThreadParameter);


---------------------------------------------------------------------

스레드생성 파라미터 dwCreateionFlags

CREATE_SUSPENDED를 준다면 대기카운트 1의값을갖고 블럭상태로 생성.


SuspendThread() <-> ResumeThread()
SuspendCount(대기 카운트) 증가, 감소

0이되면 스레드가 꺠어나 돌아간다.


---------------------------------------------------------------------

SuspendThread, ResumeThread

자기자신을 대상으로 SuspendCount를 올릴수도있지만,
외부에서 스레드를 제어할수 있기 때문에 권장 X

---------------------------------------------------------------------

Thread ID

스레드 ID는 시스템상에서 부여되는 스레드의 번호

중복되지않으나 재생성에 대해 유니크하지않다.

---------------------------------------------------------------------

Thread HANDLE

스레드핸들은 스레드커널오브젝트를 접근하기 위한 수단 

---------------------------------------------------------------------

GetCurrentThreadID

자기자신의 스레드 ID를 반환한다.

---------------------------------------------------------------------

GetCurrentThread

자기자신을 가리키는 가상핸들을 리턴한다.
어떤 스레드에서든 가상핸들값은 같은 값이다.

---------------------------------------------------------------------

DuplicateHandle()

핸들의 복사는 DuplicateHandle()과 같은 과정을 거쳐야 한다.
단순히 핸들을 임의적으로 얻는다는것은 존재하지않고, 존재해서도 안됨.

---------------------------------------------------------------------

스레드의 종료

바깥에서는 스레드의 종료를 Signal/Non-signal로 판단한다.

STILL_ACTIVE라는 ExitCode가 존재하지만 이는 define상수값이므로 
signal을 대상으로 스레드의 종료여부를 판단해야 한다.


---------------------------------------------------------------------

스레드의 종료 함수 (금지)

ExitThread() - 스레드 안에서 즉시 자기자신의 스레드를 종료
TerminateThread() - 외부에서 특정 스레드를 강제로 종료.


종료의 순간은 스레드 자기자신이 결정하고 하던일에대한 정리를 해야함.
위 두함수는 절대로 사용해서는 안된다.

단, 어떤 사유로 인해 스레드에게 종료를 요청했으나 응답이없는 경우,
강제로 파괴하거나 무시한다. (프로세스가 종료되면 알아서 종료됨)

---------------------------------------------------------------------

endthreadex()

_beginthreadex()와 대응되는 함수로, 지역객체에 대한 소멸권한은
함수자체에 하드코딩 된것이므로 이 역시 사용 금지.

---------------------------------------------------------------------

Thread 강제종료를 금지하는 이유


어차피 프로세스를 끌건데 왜 이런 방식을 고수해야 하는가?

메인스레드가 리턴되면 전역객체에 대한 소멸자호출이 된다.
이때 다른 스레드에서 전역객체를 참조하는 코드가 있다면 예외발생.

이는 단순히 예외참조 오류가 아니라 런타임라이브러리 예외이기 때문에
디버깅이 굉장히 난해해진다. (어디가 문제인지도 파악불가) 

---------------------------------------------------------------------

블락이 걸리는 상황

I/O, 동기화객체 블락, 특정 커널오브젝트의 Signal기다림, Sleep, 서스펜드

등 여러가지상황이 있음.

---------------------------------------------------------------------

Sleep(0)

자신이 가진 타임슬라이스를 포기하고 ReadQ맨뒤로 들어감.
자신과 우선순위가 같은 스레드가 있었다면 제어권이 넘어갈 것.

1. 락을 걸기엔 너무 멀고 락을 걸지않고 기다리기에는 불필요함
2. 일부러 컨텍스트 스위칭을 유도하여 버그 테스트를 하는 환경

Sleep(0)역시 컨텍스트 스위칭이 호출된다.

---------------------------------------------------------------------

Sleep(n)

n초만큼 해당스레드를 block시킨다.
블락당하는것으로, 해당 스레드보다 우선순위가 낮더라도 제어권 캐치가능.

---------------------------------------------------------------------

busy Wait은 사용금지

특이한 상황이라 의도한 경우가 아니라면,
스레드는 할일이 없을때 block, 할일이 있을때 깨어나 일을 한다.

---------------------------------------------------------------------

polling방식

polling방식(주기적으로 확인) 하는 방식인 경우 코어하나를 100%먹을 것.
Select의 단점으로 꼽히는 부분이다.

---------------------------------------------------------------------

스레드 파라미터

사용자 마음대로 넣는다. 대부분이 스레드 구분자로 사용한다.

---------------------------------------------------------------------

rand()에서 구분자 활용

srand() 시드값은 라이브러리 내부 getptd구조체에 저장되고,
이는 스레드마다 존재하기때문에 같은스레드 내에서 중복된다.

따라서 파라미터 구분자를 이용하면 될것.

(또는 ThreadID, 스택메모리 주소등을 이용해도 될것)

---------------------------------------------------------------------

std::thread

_beginthreadex가 익숙해지면 std::thread를 사용하는것을 권장한다.
단 std::thread를 사용하는 경우 내부적으로 어떻게 돌아가는지
정확히 파악하고 사용해야 한다. (f11로 들어가서 소스코드 파악)

---------------------------------------------------------------------

exitprocess()

해당 프로세스를 종료시키는 API함수.
프로세스 자체를 억지로 종료시키면 전역/static의 소멸자 호출 X,
지역객체 역시 종료의 기회를 얻지 못함.

---------------------------------------------------------------------

exit()

exitprocess를 런타임 라이브러리에서 랩핑한것으로,
전역/지역 객체의 소멸자 호출정리 작업이 들어간다.

---------------------------------------------------------------------

atexit()

인자로 함수 포인터를 넣으면 해당 프로세스가 종료될때 호출된다.

---------------------------------------------------------------------

최초의 스레드 프로시져

실제스레드 프로시져는 런타임 라이브러리 내부에 있고
몇개의 내부를 거쳐 메인문을 호출시킨다.

---------------------------------------------------------------------
---------------------------------------------------------------------

스레드 동기화

---------------------------------------------------------------------

Interlocked

인터락은 동기화 함수지만 동기화[객체]가 아니다.

인터락 함수들은 여러스레드에서 공유되는 변수를 대입/연산, 값교체 등과
같은 행동에 대한 원자성을 보장해주는 매크로 함수.

(내부에서 CPU차원에서 지원되는 interlocekd명령어를 사용한다.)


똑같은 메모리에 동시에 접근한다면 CPU가 잠시 잠기게된다.

---------------------------------------------------------------------

OS차원에서의 기다림 vs CPU차원에서의 기다림


동기화객체 - OS차원 - block이후 signal 발생시 깨움

인터락함수 - CPU차원 - CPU차원에서 지원하는 명령어수행

---------------------------------------------------------------------

CPU차원에서의 명령어 - CPU차원

컨텍스트 스위칭이 발생하는 형태가 아니며, 단순히 해당 메모리에
접근하기위해 잠깐 기다리는 것을 말한다.

 - 누군가 사용하고있다면 해당명령어가 잠깐 느린것처럼 작동.

 - 인터럽트가 없기때문에 타임슬라이스 발생 증가 X

 - 할당시간이 초과해도 해당 명령어가 끝나야 인터럽트 처리가능.

---------------------------------------------------------------------

인터락 함수 특성

인터락역시 내부에서 속도가 떨어지므로, 남발하면 성능저하.

인터락으로 변경시키는 변수는 반드시 경계에 서야하며,
캐시라인에 걸쳐지면 안된다.

언어가 할수있는 것이아니므로 API함수이며, CPU가 지원해야 한다.

---------------------------------------------------------------------

인터락 함수 에러

경계에 서지않은 경우,

인터락128은 인터락함수자체에서 에러가 난다.
나머지 함수들은 경계에 서지않으면 행위가 보장되지않는다.

---------------------------------------------------------------------

InterlockedIncrement()

증가된값을 리턴해준다.
원자성이 보장되지만 결과값을 모르기때문에 리턴값은 굉장히 많이사용

---------------------------------------------------------------------

InterlockedExchange()

어떤 변수를 증가시킬때, 다른곳에서 대입하는것은 문제 X
(캐시라인이 틀어졌다면 역시 문제있음)

InterlockedExchange()의 리턴값은 원래 저장된 값이 나오기때문에,
이값을 확인하는 방식으로 사용된다.

단순히 대입을 한다고한다면 아무런 특징이 없다.

---------------------------------------------------------------------

InterlockedCompareExchange()

비교할 값자체도 임의의값인 경우 사용된다.

---------------------------------------------------------------------

WaitOnAddress

주소값을 기다리고, 해당 주소값이 변경되는 경우 깨어난다.
이 개념의 등장으로 동기화 객체에 대한 개념이 윈도우 내부에서 
완전히 바뀌었다.

아직 작동원리 파악 X

---------------------------------------------------------------------

스레드 디버깅

스레드창에서 특정스레드를 중지시켜 돌지 못하게 할수있음.

밧줄꼬인 표시가 나기도 하는데, 이는 다른스레드가 이 구간에 있음을 뜻함.

병렬스택 창에서 스레드가 어떤식으로 도는지 알수있음.

---------------------------------------------------------------------

Critical Section (유저 동기화객체)

기본은 유저모드고, 경합이 발생되면 커널모드로 전환이 일어난다.
스레드가 블락당한다는것은 커널모드에서만 가능하다.


	CRITICAL_SECTION cs;
	InitializeCriticalSection(&cs);

	EnterCriticalSection(&cs);
	//동기화
	LeaveCriticalSection(&cs);


	DeleteCriticalSection(&cs);



---------------------------------------------------------------------

InitializeCriticalSection()

큰의미는 없으며, 해당 구조체를 0으로 만드는 느낌.

---------------------------------------------------------------------

CriticalSection의 장점

크리티컬 섹션은 내부에 스레드 아이디가 보관되고, 
스레드 내부에서 재귀호출이 가능하다.

내부적으로 카운팅되므로 획득한만큼 해제(Release) 해야한다.


재귀획득은 개발자에게 굉장히 큰 장점이 된다.

---------------------------------------------------------------------

TryEnterCriticalSection()

들어갈수 있냐없냐를 시도하는함수. 권장하지않는다.

임계영역을 block없이 획득하거나, 자기자신이 들어가 있는경우 TRUE
다른스레드가 이미 임계영역을 소유한 경우 FALSE

---------------------------------------------------------------------


EnterCriticalSection

이 함수가 실제로 하는일은 Interlocekd을 체크하는 함수호출하고 빠진다.
(인터락 관련함수 비트체크 flag를 올려놓고 카운트를 차감하며 빠짐)

카운트는 마이너스로 들어간다.

---------------------------------------------------------------------

CriticalSection 성능

경합이 발생하지않는다면 InterlockedIncrement 하는것과 성능 비슷.

함수 내부에서 스레드ID가 다른경우(경합발생) CreateEvent로 커널동기화
오브젝트를 생성하고 이를 대상으로 block.


동기화객체가 무수히 많이 들어갔어도 경합이 없다면 성능은 떨어지지않는다.
(단순히 Interlocked체크만 하고 빠질것이기 때문)

따라서 동기화객체 개수보다 경합의 발생유무가 중요하다.

---------------------------------------------------------------------

DeleteCriticalSection();

CriticalSection은 개발자가 선언했지만 명시적으로 Delete도 호출.
옛날에는 크리티컬섹션 구조체안에 스레드ID, 카운트, 세마포어 핸들있었음.
(실제로는 이벤트 객체)

---------------------------------------------------------------------

변경된 CriticalSection

이는 겉모양은 유저모드지만 내부에서 커널오브젝트가 만들어진 것으로,
유저모드에서 동작할 수 있는 동기화 객체는 존재하지 않았다.

하지만 윈도우 10 Core부터 세마포어가 아닌 완벽하게 유저모드에서
존재하는 동기화객체가 새로 개발이 된 상태.


---------------------------------------------------------------------

변경된 이후 DeleteCriticalSection();

본디 Del..()는 내부 동기화객체를 해제하기위해 호출하는것으로,
경합이 없는 경우 의미없는 함수 호출이 된다.

완전이 유저동기화 객체로 넘어온 이후부터는 쓰지않아도되는 함수가되버렸다.

---------------------------------------------------------------------

스레드 프로그래밍 설계 시

성능을 높이기 위해 병렬처리를 극대화시킨 복잡한 설계를 한다면,
오히려 성능이 떨어지거나 유지보수가 힘들어지기 때문에
스레드 프로그래밍은 항상 간단하게 설게해야한다.

---------------------------------------------------------------------

KidEvent등장 (-> Waitonaddress)

windows10 Core부터 새로운 개념의 동기화 객체 등장
이전 구조에서는 Enter에 성공하면 세마포어 커널오브젝트 이벤트를 만듬.

---------------------------------------------------------------------

CriticalSection 결함

스레드ID를 체크하여 동기화가 걸려야 하는 순간에
CriticalSection은 커널오브젝트를 내부에서 생성한다.

커널오브젝트는 생성에 실패할 가능성이 존재하고,
이는 CriticalSection은 구조적 결함을 가지고 있었다는 뜻이된다.

---------------------------------------------------------------------

CreateKidEvent (->WaitOnAddress()로 바뀜)

KidEvent생성은 이벤트 커널오브젝트가 아니라 이미 만들어진 객체개념.

이 개념의 등장으로 CriticalSection동기화의 개념이 완전히 유저오브젝트.
(기존에는 동기화시 커널오브젝트 사용)

멤버변수는 세마포어로 존재하지만 실제 이벤트객체는 유저이벤트.


---------------------------------------------------------------------

WaitOnAddress()

최근에나온 API로 지정된 주소의 값이 변경될때까지 기다린다.

실제 내부 작동방식이 구현된바는 없다.

---------------------------------------------------------------------

SRWLock 의 등장

SleepReadWriteLock은 현재 동기화객체중 가장 성능이 좋다.

SRWLock을 주력으로 쓰되 구조상 어쩔수없이 재귀형태가 필요하다면
CriticalSection으로 전환하는것을 권장한다.

---------------------------------------------------------------------

SRWLock 동기화 체크

비트체크 후 빠진다. 스레드 아이디체크하는 과정이 없기때문에
재귀호출이 허용되지않고 더 빠르고 가볍다.

Acquire를 같은곳에서 두번하면 그 즉시 데드락이다.

---------------------------------------------------------------------

SRWLock 사용함수


SRWLock Srwlock;
void InitializeSRWLock(PSRWLOCK SRWLock);	//값 초기화.


void AcquireSRWLockExclusive(PSRWLOCK SRWLock); //독점접근.
void AcquireSRWLockShared(PSRWLOCK SRWLock);    //Shared끼리 접근허용


void ReleaseSRWLockExclusive(PSRWLOCK SRWLock);
void ReleaseSRWLockShared(PSRWLOCK SRWLock);


bool TryAcquireSRWLockExclusive(PSRWLOCK SRWLock);
bool TryAcquireSRWLockShared(PSRWLOCK SRWLock);

Try관련함수는 마찬가지로 잘 사용하지않는다.

---------------------------------------------------------------------

SRWLock사용시 주의 할 점

[Lock - UnLock - Lock] 과 같은 형태의 코드가 나왔을 경우,

A스레드가 SRWLock을 Release하면 대기하던 스레드B는 깨지않고
다시금 A스레드가 Lock된다.


커널오브젝트의 경우 대기중인 스레드가 깨겠지만,
SRWLock은 최대한 가볍게 만들다 보니 이러한 과정들이 생략되어버린다.

---------------------------------------------------------------------

파악되지 않은 것

커널모드로의 전환이 없다는것은 block중인 스레드를 깨울 수 없다.
그런데 현재 win10 Core부터는 유저동기화객체가 완전히 유저쪽으로 넘어왔다.

이 구조대로라면 누군가 들어가서 깨우는것이아니라 혼자 깨어나야하는데..
이것이 가능한가.?

---------------------------------------------------------------------

SpinLock

해당 자원을 획득하기 위해 타임슬라이스를 소모하며 루프를 도는 행위

락이 걸린 상태에서 내 타임슬라이스 안에 락이 해제가 된다면 가장 좋음.

---------------------------------------------------------------------

동기화객체 vs SpinLock

동기화객체로 스레드가 블락되면
[내 타임슬라이스 포기 -> Block상태 -> ReadyQ들어감 -> 순서기다림]

spinLock은 CPU를 계속사용하면서 확인함


---------------------------------------------------------------------

SpinLock이 사용되는 곳

CriticalSection, SRWLock과 같은 유저 동기화 객체들은 
내부적으로 스핀락이 내장되어 짧은시간 시도후 block당하러 가게된다.

--------------------------------------------------------------------

InitializeCriticalSectionAndSpinCount()

크리티컬 섹션에서 SpinLock의 Count를 조절할 수 있는 함수이다.
해당 Count회수만큼 시도하고 Block으로 빠지게 된다.

해당 default 회수는 수시로 바뀌므로 상수로 기억 X



--------------------------------------------------------------------

스레드 동기화 vs SpinLock, LockFree

스레드 동기화객체를 주로 사용하는 경우, 동접자가 높아지고 
서버가 버벅이는데도 CPU점유율이 잘 높아지지 않는 경우가 있다.


반대로 스핀락, 락프리를 주로사용하는 경우 CPU사용률 자체는 높아지지만,
처리속도가 좀더 빨라질 수 있다.
(이는 무조건적으로 락프리가 빠르다고 말할 수 없음)

---------------------------------------------------------------------

yeildProcesser()

WINAPI에는 yeildProcesser()라는 매크로함수가 존재한다.
이 함수는 pause명령어를 수행한다.

---------------------------------------------------------------------

pause()명령어

pause는 어셈블리 명령어로 존재하며,
하이퍼 스레딩에서 일부러 명령어 하나를 쉬는 명령어이다.

하이퍼스레딩이 지원되지않으면 pause는 의미없는 행위이다.

---------------------------------------------------------------------

NOP어셈블리 명령어

보통 점프 테이블에서 사용되며, 공백과 같은 어떤 연산도 없는 명령어이다.

pause는 이러한 NOP명령어와 동급.

---------------------------------------------------------------------

하이퍼 스레딩

하이퍼 스레딩은 캐시미스 등으로 인한 여유가 생길 때,
파이프라인에서 명령어 로드/패치 메모리 적재등과 같은 과정을 번갈아가며 시도

pause가 하는일은 명령은 없고 이번타임 쉬는것으로,
일부러 명령하나를 버려서 하이퍼스레딩으로 옆스레드가 돌게끔 하는 것.

OS입장에서는 하이퍼스레딩지원 코어 하나를 2개의 코어로 본다.

---------------------------------------------------------------------

하이퍼스레딩 기반 CPU의 SpinLock구현

하이퍼스레딩 CPU의 경우 SpinLock을 구현할때 항상 pause를 넣으며,
거의 정석처럼 받아들여지고 있다. (MS가 이렇게 구현된다.)

---------------------------------------------------------------------

SpinLock에 Pause를 넣는 이유

1번코어 - 스핀락 시도중
2번코어 - 자원 사용중

이때 2번코어로 도는 스레드가 block당했거나 ReadyQ에 있다면,
1번 코어의 스레드는 SpinLock을 아무리 돌아도 자원을 획득하지 못한다.

이와같은 불필요한 상황을 피하기 위해 하이퍼스레딩에서는 Pause명령어를
이용해서 한번씩 다른쪽으로 전환시킨다.

---------------------------------------------------------------------

WaitForMultipleObjects()

여러개의 커널오브젝트를 대상으로 한번에 기다림

Signal/Non-Signal은 동기화 / 종료여부 두가지 용도로 사용가능.


---------------------------------------------------------------------

커널 동기화 객체

단순히 확인하는 과정절차도 커널모드 전환이 일어남
이는 큰 성능차이이므로, 유저모드 객체를 사용

---------------------------------------------------------------------

Mutex

뮤텍스는 커널객체

뮤텍스는 서로다른 프로세스가 접근할 수 있는 특징이 있음.
CreateMutex시 이름을 지정 가능.

클라에서 중복실행을 막을때 사용하는 경우가 있었음.

---------------------------------------------------------------------

Semaphore

뮤텍스보다 큰 개념으로, 복수 접근이 가능하다는 특징이 있다.

모든 동기화객체는 획득한곳에서 락을 풀어야하는데,
세마포어 같은 경우는 다른쪽에서 푸는것이 가능하다.

이는 접근카운트를 차단하는 느낌이다.

---------------------------------------------------------------------

동기화 이슈 - 방향성

한쪽에서는 false로 확인하여 작업, 완료되면 true.
다른쪽에서는 무조건 false로만 바꿔주는 형태

이와같은 경우 동기화객체를 사용하지않아도 무방

---------------------------------------------------------------------

Event

가장 기본적인 동기화객체 베이스로, Mutex, Semaphore역시 이벤트사용

SetEvent() - Signal 전달 (2번호출되도 소용X)
ResetEvent() - Non-signal 로 전환 (AutoReset의 경우 사용금지)

---------------------------------------------------------------------

SetEvent 스레드가 깨어나는 방식


이벤트는 스레드를 리스트로 관리하므로, 순서를지켜 wait한 순서대로나옴.
단, 이 순서에 의존한 코딩은 해서는 안된다.
깨어나는 순서는 보장되지만, 어떤스레드가 먼저 일을 끝낼지는 보장X


캐시히트를 높이기 위해서는 스택방식으로 깨어나는것이 더 좋을것.
IOCP는 스택방식으로 깨어난다.


---------------------------------------------------------------------

CreateEvent모양

HANDLE CreateEventA
(
  LPSECURITY_ATTRIBUTES lpEventAttributes,	
  BOOL                  bManualReset,	
  BOOL                  bInitialState,		
  LPCSTR                lpName
);


bInitalState - 최초 스레드 상태지정. TRUE = signal, FALSE = Nonsignal;

---------------------------------------------------------------------

수동리셋모드


SetEvent 

 - Signal상태로 변경. 여러스레드일 경우 모두 다 깨움 
   ResetEvent가 호출될때까지 signal상태로 둠.


ResetEvent

 - NonSignal로 바꿈


PulseEvent

 - 대기중인 스레드를 모두 깨운다음 다시 Non-Signal상태로 전환

--------------------------------------------------------------------

자동리셋 모드


SetEvent 

 - Signal상태로 변경. 여러 스레드인경우 하나만 깨움.


ResetEvent

 - 자동리셋모드에서는 사용 X. 자동으로 Non-Signal이 된다.


PulseEvent

 - 대기중인 스레드 하나를 꺠운다음 다시 Non-Signal상태로 전환


---------------------------------------------------------------------

Event의 사용처 - 스레드풀

워커스레드를 여러개만들어 EventObject를 상태로 기다림
SetEvent로 signal을 주면 스레드중 하나가 깨어나서 일을 시작

모든스레드가 일을 진행할때(signal), SetEvent를 호출하면 아무일 X
일을끝내고 WaitFor로 Non-Signal로 변경됐을때, SetEvent하면 깨어남(signal)

---------------------------------------------------------------------

스레드 풀에서의 오토리셋 / 메뉴얼리셋

스레드 풀로 쓰고자한다면 AutoReset모드.
의도적으로 대기중인 모든스레드를 깨우고자할때 ManualReset.


AutoReset - Jop을 던져서 일을해야 할때.
ManualReset - 종료할때 사용 (종료Jop을 던져 종료해도 상관X)

---------------------------------------------------------------------

일반적으로는 AutoReset은 잘 사용하지않는다.

---------------------------------------------------------------------

Event의 다른 사용처

IOCP, Windows Server등에서 사용된다.
WINAPI에도 스레드풀이 제공되는데, 내부는 IOCP로 구현되어있음.

---------------------------------------------------------------------

동기화 객체 해제(Leave)시 주의할점

Enter/Leave로 감싼 코드에서 분기문이 나오는 경우,
Leave가 여기저기서 호출될 것이다.

이는 코드가 난잡해지고 DeadLock의 확률 증가.


1. C++객체를 이용해 생성자/소멸자로 해결 (성능하락) 소멸자인라인처리 X


---------------------------------------------------------------------

캐시 미스가 나는 이유

데이터가 변경되었는데, 다른코어 캐시라인에도 이 데이터가 있는 경우
이를 전파하는것이 낭비이므로 해당 캐시라인에 대해 캐시무효화를 선언

---------------------------------------------------------------------

Meltdown (붕괴)

커널메모리에 접근되는 상황을 말함.

---------------------------------------------------------------------

Out-Of-Order

명령어 재배치를 말한다. 
CPU의 성능향상은 단순히 클럭증가가 아니라, 명령어 재배치가 들어갔기때문

명령어 재배치는 어셈블리 명령어들이 순서를 지키며 실행되지않고
밑에있는 코드를 더 빨리처리할수 있다고 판단되면 먼저 처리.
(CPU차원의 컴파일러 최적화와 비슷한 맥락)

---------------------------------------------------------------------

분기예측

다음 실행될 조건문이 어떤곳으로 분기할지 알기전에 미리 추측하는 기술
CPU는 OutofOrder이외에도 분기예측이 들어간다.

미리 추측하여 분기를 판단하여, 예측에 성공했다면 큰 성능향상,
실패한다면 원래하던대로 돌아감.

---------------------------------------------------------------------

OutofOrdering으로 인한 Meltdown

OOO로 순서가 바뀌어 커널메모리에 접근하는 현상.
(구현하려고 해봐도 잘안되고, 샘플코드를 봐도 잘...)

CPU가 봤을때 전혀 연관성이 없어보이는것을 바꾸기 때문에,
우리입장에서 왠만해서는 걱정할 필요 X

---------------------------------------------------------------------

OOO로 인한 동기화 이슈

아무상관없는 메모리를 바꿨음에도 다른쪽스레드에 변화가능성 있음.
미묘한 동기화이슈 발생확률 존재.

보통은 락을 걸기때문에 신경쓰지않는다.(경험하기 쉽지않음)

---------------------------------------------------------------------

Memory Barrier(메모리 베리어)

위와같이 OutofOrder로 멜트다운을 막기위해 MemoryBarrier라는 개념도입
메모리 베리어는 명령어 재배치를 무효화 시키는 것(volatile과 같은맥락)

---------------------------------------------------------------------

_mm_fence()

#include <intrin.h> 필요

이 명령어를 기준으로 위와 아래를 섞지 않겠다는 명령어이다.

---------------------------------------------------------------------

__ReadWriteBarrier()  (= Compilerbarrier)

WinAPI에도 등장하는 _ReadWriteBarrier()는 최적화 컴파일시
코드가 뒤섞이지 않도록 한다.

CPU차원에서의 OOO를 말하는것이 아님.

msdn에서는 이 함수말고 std::atomic_thread_fence()를 권장

---------------------------------------------------------------------

atomic_thread_fenc();


https://en.cppreference.com/w/cpp/atomic/memory_order 

참조.


이때 fence가 최적화컴파일 수준인지, OOO인지 잘 기억.

---------------------------------------------------------------------

Acquire 는 CPU입장에서 메모리를 읽어오는 개념(Load)

Release는 CPU입장에서 메모리를 저장하는 개념(Store)

Acquire베리어 - Load명령어가 위에서 아래로 내려오지 못함

Release메모리 디펜스는 아래있는 명령어를 위로 올리지 않음

---------------------------------------------------------------------

Memory_order_seq_cst
(위 구현은 vs버전마다 바뀔수있으니 항시 확인)

atomic_thread_fence()내부로 해당인자가 들어가면,

1. Guard변수 선언
2. InterlockedIncrement()를 사용해 Guard가 0일경우 0으로 바꿈.

---------------------------------------------------------------------

Interlocked와 OutOfOrder

Interlocked관련된 모든 함수에서는 도입부에 MemoryLock이 들어가고,
이 MemoryLock을 기점으로 OutOfOrdering이 발생할 수 없다.

따라서 의미없는 Interlocked호출로 MemoryLock을 MemoryBarrier기능으로 활용.

---------------------------------------------------------------------

mfence vs Interlocked

mfence라는 MemoryBarrier기능 명령어가 나왔음에도,
Interlocked이 더 빠르기 때문에 대부분 이러한 방식을 사용.

ms포럼에서도 언급되었지만, MS쪽에서 용도가 다르니 성능비교하지말라고함.

---------------------------------------------------------------------

faststorefenc()

새로나온 기능으로, 기존 메모리베리어 보다 빠르다.

rsp(스택포인터 자체)에 쓸모없는 메모리를 0으로 (or)연산한다.

--------------------------------------------------------------------

메모리베리어의 적용

임베디드나 커널쪽같은 심오한 작업인 경우 고려해볼만 하지만,
일반적인 게임서버 컨텐츠쪽에서는 유지보수가 전혀 되지않음.

--------------------------------------------------------------------

피터슨 알고리즘과 OOO

피터슨알고리즘은 개념적으로는 완벽하지만 OO0때문에 버그가 나온다.

--------------------------------------------------------------------

동기화 성능이슈 - 사본을 활용하는 방식

동기화를 걸고 저장을 시도하는 것이 아니라, 
데이터 사본을 따로 만들어 Save한다면 성능 향상의 이점.

메모리카피 < 파일 입출력 (파일 입출력이 더 무거움)

--------------------------------------------------------------------

사본활용 - 클라에서 활용방식

로직/렌더를 분리시켜도 ObjList자체에 락을 걸면 병렬화의미 X


로직수행 / 사본을가지고 Render 
보통 로직쪽이 훨씬 가볍기 때문에 로직쪽에서 사본까지 만들어줌.

사본을 만드는 시간과 동기화에 걸리는 시간을 잘 비교분석하여 적용.

--------------------------------------------------------------------

멀티스레드 기능분리

거의 대부분은 역효과가 남.
병렬로 돈다고 해도 불필요한 작업(사본만들기 등)으로인한 오버헤드 주의

CPU사용률이 굉장히 높아지는 상황에서는 Lock을 거는것이 나을 수있음.
(block당해 쉬는동안 다른쪽 일을 처리할 것이므로)

--------------------------------------------------------------------

멀티스레드 성능측정

1. 코드의 수행시간
2. 초당처리 회수
3. 서버-클라간 응답속도

모든것에서 우위를 저하는 방식은 존재하지 않는다.
코드블럭 지정으로 수행시간을 측정하는 프로파일러는 일부 성능측정임


A로직의 처리는 느리지만 서버입장에서 처리속도는 빨라질수도 있음.

비동기 서버의 경우 초당TPS와 응답속도는 항시 상반된 속도이다.

--------------------------------------------------------------------

Actor패턴 (생산자 - 소비자 패턴)

MainThread가 처리하는것이 부담되어 별도 스레드에게 일감을 던지는 것

Signal을 줬지만 해당스레드가 작업중이라면 무시되므로, JopQ가 나와야함


ReActor패턴 - WorkerThread가 JOP을 진행하고 마무리까지한다.
ProActor패턴 - WorkerThread가 JOP을 진행하고 결과를 알려준다.

Overlapped I/O는 구조자체가 Actor패턴이다.

--------------------------------------------------------------------

ProActor패턴의 동기화 이슈

결과를 받아 마무리하는 ProActor패턴이라면, 메인로직스레드와 동기화이슈.

별도의 thread로 뺀다는것은 완전히 병렬로 돌수있을때를 가정해야한다.

--------------------------------------------------------------------

다양한 설계방법

1. thread를 역할로 구분하고 JOP을 던지는 구조

2. 별도의 ThreadPool이 존재하고, 상황에 맞는 Jop을 던지면 여러개의 
    WorkerThread가 처리

	
--------------------------------------------------------------------

게임서버 설계

가장 대중적인 선호방식은 mainthread를 싱글로가고, 필요한 부분을
thread로 따로빼서 병렬 처리하는 것이다.

(검은사막, 리니지와 같은 큰기업은 완전한 멀티스레딩으로 간다)

--------------------------------------------------------------------

메인로직 단일스레드 구조

mainthread를 싱글로 가는 구조는 thread별로 기능이 정해져있기 때문에
코어개수에 비례하여 성능이 높아지지 않는다.

두개이상 늘린다면 설계상 문제가 될수도 있음.

--------------------------------------------------------------------

메인로직 단일스레드 구조 - DB

클라가 서버접속시 DB로딩.

DB저장은 결과가 필요없으므로 단순히 DB스레드에 던지는것으로 끝.

불가피하게 나오는 상황을 제외하고는 컨텐츠 로직상에서
DB를 읽는 행위는 최대한 없애야 함

--------------------------------------------------------------------

DB저장 실패

그뒤로 저장되는 데이터가 모두 꼬일것이기 때문에, 
이는 서버를 꺼야하는 중대한 상황이다.

--------------------------------------------------------------------

Write / read의 비동기

유저가 플레이하는 동안 생기는 일은 로직상에서 모두 Write.

Write는 작업을 던져주면 되므로 비동기가 쉬우나, 
읽기는 비동기 처리가 매우 난해하다.
(어떤 데이터를 읽고자했는데 아직 읽혀지지않은 경우)

-------------------------------------------------------------------

JOP을 전달하는 방법

JOP은 해당객체에 대한 포인터로 던지는경우 안전성보장 X
JOP을 던질때는 저장에 필요한 모든 데이터가 들어가야한다.

단 링버퍼와 방식(memcpy)이라면 성능이 매우떨어지고 대량의 데이터필요.

이를 개선하기위해 메시지잡에서 [headr(type, Len) - Data] 형식 사용.

--------------------------------------------------------------------

링버퍼 동기화 이슈

각기 다른 thread에서 Inqueue와 Dequeue한다면 동기화 필요 X
단, 같은일을 여러개의 workerthread가 존재한다면 어쩔수없이 동기화.

--------------------------------------------------------------------

링버퍼 동기화객체의 위치.

링버퍼에 동기화객체가 필요한 경우, 

1. 내부에서 Lock/UnLock하고 사용자는 사용만 함
2. 내부에 객체만 포함시키고, 사용자가 직접 Lock/UnLcok.

--------------------------------------------------------------------

멀티스레드 설계소개

멀티스레딩 설계는 정형화하여 암기 X

--------------------------------------------------------------------

AcceptThread 

listenSocket은 blockSocket으로간다.

초당 5000TPS(정확X) 가 나오기때문에 굳이 논블럭으로 할 필요없음

한다면 성능향상을 볼수있긴함

--------------------------------------------------------------------
--------------------------------------------------------------------


1. 고전적인 형태의 서버모델


I/O WorkerThread

송/수신 완료 통지 담당
비동기 Send, Recv를 사용하여 데이터를 카피하는 행동은 커널내부에서.
우리입장에서 일을 던지고 통지를 받으므로 ProActor패턴.

--------------------------------------------------------------------

SendThread

고전적인 IOCP설계에서는 항시 SendThread가 나옴.
우리는 일부러 고달프게 하기위해, 사용하지않고 간다.

--------------------------------------------------------------------

UpdateThread

게임특성상 멀티스레드 환경에서 메시지처리가 난해함.
따라서 고전적인 IOCP모델은 모든 로직처리를 한곳에서 함.

따라서 모든 부담이 이쪽 스레드로 몰리게된다.

--------------------------------------------------------------------
 
TimerThread

TimeThread는 Queue에 들어온것들을 받아서 깨어난다.
TimerEvent Proc쪽에서 Event들에 대한 정보를 뽑아 주기적으로 도는 로직.


게임서버에서는 사용자가 별다른 입력이 없어도 월드가 살아있어야함.
(캐릭터 이동시, 지점마다 모두 TimeEvent로 등록하는 형태)

--------------------------------------------------------------------

TimerThread단점

메시지 던질때 Copy, 뽑을때도 Copy, Proc에 로직처리 -> 성능하락
Event에 쌓이는 데이터양이 어마어마함 -> 메모리 낭비

따라서 Timer설계는 구조만 복잡해질뿐 좋은 효과를 내지못함.
(스레드 오버헤드로인한 역효과)

--------------------------------------------------------------------
--------------------------------------------------------------------

2. 중심부에서 모든것을 처리하고, 기능별 분산


mainThread

SelectModel로 서버를 만들때와 같으며, 엄청난 코드량이 내장됨.
네트워크 처리를 제외한 패킷처리, 컨텐츠처리 등 모든부하가 이곳으로 집중

--------------------------------------------------------------------

인증용 Thread, 로그인전담 Thread

먼저 캐릭터 로그인에 대해 정보를 처리한다음, DB로딩을 다른Thread에서 진행

--------------------------------------------------------------------

DB Save Thread

DB에 저장할 데이터가있다고 한다면 인큐하고, 이스레드는 DB에저장한다.

--------------------------------------------------------------------

싱글스레드 구조

1,2 두 모델은 둘다 스레드가 여러개지만 메인스레드가 하나이므로,
싱글스레드 로직으로 본다.

싱글스레드는 가장 일반적인 구조이나 듀얼CPU/멀티코어 입장에서는
가장 부담되는 일을 한쪽에 몰아넣은 것이기 때문에 비효율적인 구조

--------------------------------------------------------------------

코어가 늘수록 빨라지는 병렬구조

완료통지가 올때마다 각자가 받은 메시지 PacketProc를 처리하는 구조로,
WorkerThread를 늘리고 코어가 늘어날수록 빨라지는 병렬구조.

유저간의 상호작용이 없는 컨텐츠거나,
웹서버의 경우 이러한 구조를 따른다.

--------------------------------------------------------------------

멀티스레드 구조

하나의 큐에 데이터를 쌓아놓고 여러개의 UpdateThread가 일 처리.

문제 1. UpdateThread에 대한 동기화 이슈 (공용자원)
문제 2. Session을 기준으로 한 순서처리문제

.....................................................................

문제1. Session을 기준으로 한 순서처리 문제

서버로직 기준으로 A유저,B유저중 누가 먼저 처리되는 것은 상관 X
하나의 유저를 대상으로 하는 처리순서를 말함.

한유저에 대한 메시지를 여러스레드가 뽑아 처리하는것은 불가능.

.....................................................................

순서처리 해결 방안

UpdateThread마다 Q를 두고 유저별로 스레드를 지정해 넣는 형태


--------------------------------------------------------------------

워커스레드에서 로직까지 처리 vs 별도 스레드로 분리

....................................................................

찬성쪽 입장

Send/Recv의 IO작업에 우선권을 둬야하고, 
WorkerThread는 I/O작업만 전담하며 다른부담은 X

부담을 몰아줄 경우 Send/Recv에 대한 처리에 문제 가능성


....................................................................

반대쪽 입장

직접 처리하는것이 가능한데 스레드를 별도로 빼는것은 비효율적임

큐에 Copy, 큐에서 스레드로 Copy, 스레드 자체 오버헤드...등

서버에서 안중요한것은 없음. 특정부분에만 중요도를 두는것은 애매함.

--------------------------------------------------------------------

멀티스레드 구조 동기화

공용자원을 쓸떄마다 Lock을 걸어버린다면, 멀티스레딩 의미 X

모든로직을 동기화로 묶을바에는 싱글스레드기반 Select모델로 가는게낫다.

--------------------------------------------------------------------

프라우드넷 샘플코드 중 의아한것

모든 PacketProc에서 직접처리하는 구조에서, 크리티컬섹션을 하나두고

[Enter - 로직 - Leave]와 같이 간다.

이는 사실상 싱글스레드와 다를바 없는 구조로, 
사람들이 엉망으로 쓰니까 이렇게라도 써먹으라고 샘플을 제공하는것.

--------------------------------------------------------------------
--------------------------------------------------------------------

게임서버 멀티스레딩 구조 설계


빈번하게 유저동기화객체가 사용된다고 하더라도,

경합이 발생되지않는다면 Interlocked체크 후 빠지기 때문에
큰 성능저하는 일어나지 않는다.

--------------------------------------------------------------------

Map별 동기화

맵이 분리되어있다면 병렬처리가 가능

워커스레드가 10개일때, 열명의 유저가 같은 맵 하나에 모두 
존재할 가능성은 크지않을 것이므로 왠만큼 병렬로 처리될 것이다.

.....................................................................

경합이 발생하는 맵끼리 이동하는 경우


A맵 -> B맵

이동하는 경우, 아무장치없이 이동시킬 수 없음. (둘다 락을걸어야함)
이동의 중간과정으로 전달 매개체가 나오는것이 일반적인 형태.

--------------------------------------------------------------------

물리적인 분리 설계

MO게임류의 방개념에서는, 방단위로 동기화객체를 가면 될것이다.

인던(=방)단위은 서로 상호작용이 없으므로 동기화를 각자 가지고간다.

--------------------------------------------------------------------

오픈월드 - Sector단위 동기화

맵이라는 구분없이 거대한 오픈월드의 경우,

섹터는 주변 섹터에게 영향을 주기때문에 통상적인 섹터가 아닌,
컨텐츠 상에서 따로 분리개념이 들어가야 한다.

(섹터마다 락을 9개씩 거는 구조는 데드락위험성도 높고 락도 너무빈번함)

--------------------------------------------------------------------

오픈월드 - 구역단위 동기화

컨텐츠 상에서만 하나의 맵이고, 플레이어들이 느끼지 못하는 구역으로 분리.

이렇게 구현할 경우 유저입장에서는 맵의 전환이 없고 하나의 월드처럼 느끼지만,
서버상에서는 어떤 던전이나 맵을 이동한다는 개념이 들어가고 있는 것.

이때 서버상의 구역간 경계에서는 전투나 특정컨텐츠가 안되는 제한이있음.
(특정 탈것을 타고 이동해야 하는 등...)

--------------------------------------------------------------------

컨텐츠별 스레드 분리

나눠진 스레드안에 속한 유저들은 다른쪽스레드와 독립적이므로 병렬처리가능.
(단, 어떤 방식을 택하든 전체 플레이어를 관리하는 자료구조는 존재해야함)

각 스레드별로 본인한테 들어와있는 유저들을 관리하며,
한 유저는 두개이상의 스레드에 속해있을 수 없음.

.....................................................................


컨텐츠별 스레드 분리의 문제

플레이어가 다른 컨텐츠를 이용(다른 스레드로 이동)한다면 동기화 필요.
A,B스레드 모두 락을 걸고 A스레드에서 삭제, B스레드에 Push.

동기화가 매우 빈번해지며, 데드락의 위험성 내제

......................................................................

새로운 규칙, 전달 매개체등장


내가관리하는 리스트는 나만이 사용한다는 규칙이 있어야 한다.
따라서 다른스레드에서 내 유저들을 건드릴수 없음.

(이 규칙들이 존재한다면 Lock이 필요없어도 됨.)


따라서 A->B 이동은 누군가 직접건드리지않고 A에 요청하는 형태가 된다.
이 경우 스레드간의 Player(Data)를 전달시킬 수 있는 매개체가 필요.

.....................................................................

매개체를 활용한 전달

A->B스레드간 이동시


A스레드 락 -> 매개체에 push -> A스레드 유저 삭제.

스레드마다 본인이 처리할 대상들을 리스트로 관리하고, 삽입/삭제를 위해
전달 매개체를 통해서 전달받는 형태이다.

.....................................................................

매개체 전달의 단점1 - 스레드의 한계치

스레드가 정해져있기 때문에 코어개수에 비례하여 성능이 향상되지않음.

(보통 이정도의 분산도 하지않음)

......................................................................

매개체 전달의 단점2 - 유저 분포도 불균형


대부분의 유저들은 필드에 존재하므로, 하나의 컨텐츠에 부하가 쏠림.
따라서 성능만 떨어뜨린다는 관점이 존재함.

(로그인스레드는 DB로딩(모든데이터 긁어옴)을 수행해야 하므로 별도로 존재)

......................................................................

매개체 전달의 단점3-1 - 메모리 참조오류


락을 걸지않는경우, 해당메모리가 이미 없어졌다면 메모리 참조오류가 난다.

(서버는 동접자를 정하는게 보통. 최대치가 접속했을때 원할한 플레이 수치
를 정하기위해서이다. 사람이없을때 서버가 빠른것은 아무의미없음)

따라서 굳이 가변길이인 리스트가 아닌 메인자료구조를 배열로 가는것.
배열을 사용한다면 메모리참조 오류는 나지않음.

......................................................................

매개체 전달의 단점3-2 - 배열 사용시 문제


1. 배열을 순회해야 하는 문제가 생김.

2. 배열 사용으로 Crash는 피했지만, 모든 스레드가 접근해서는 안될 것.

플레이어는 하나의 스레드에 배정된 상태여야만 한다는 규칙이 있었으므로
본인이 속한 스레드 구조영역을 순회하며 본인스레드에 소속된 객체처리.

--------------------------------------------------------------------

배열 vs 리스트(맵)

리스트의 장점은 메모리의 효율적인 관리.
서버에서는 동접자가 적을때 빠른것이 아무의미없음.

하지만 배열의 경우 플레이어를 찾아야한다면 루프가 필요함
인덱스 + SessionID를 혼합하는 방식으로 개선가능.

(배열 인덱스를 순회하는것은 성능에 거의 영향 없음)


--------------------------------------------------------------------

검은사막 서버

오브젝트 단위로 동기화를 건다.
멀티스레드로 동시에 들어가면서 캐릭터단위로 Lock을 걸기때문에,
캐릭터마다 읽기용 락 / 쓰기용 락이 존재한다.

실제로 코드를 본적은 없으나 실제 작업하는 개발자도 스레드 구조모름.
규칙에따라 로직을 짜고있을 뿐...


[readLock 사본만들기 -> 사본컨텐츠 변경 -> WriteLock 걸고 실제반영]

굉장히 난해한방식으로, 일반적이지않음.

....................................................................

본 원장은 해당 방식에 부정적인 입장

이렇게 간다고해서 성능이 나올지도 의문

--------------------------------------------------------------------

리니지 서버

병렬로 메시지를 처리하는 방식으로, 오브젝트마다 메시지 큐를 둔다.

이때 경합이 발생되면 한쪽에서 포기하고 빠져나간다.
(tryCriticalSection과 비슷한 느낌)

매우 화려해보이지만 이렇게까지 해야하는 이유를 아직 찾지못함.

--------------------------------------------------------------------

호모지니어스(동종의, 균질의)

스레드 입장에서의 스케일 아웃.
같은일을 하는 스레드를 여러개가 돌고있는 것

이론적으로 스레드개수와 코어개수를 늘리면 성능이 올라간다.
(더많은 병렬처리가 가능하므로)

--------------------------------------------------------------------

헤테로지니어스 (여러 다른종류)

기능별 분산. 대부분의 게임서버 형태이다. (NC, 펄업 제외)

단, 두가지방식이 병행되는 경우도 존재한다.

--------------------------------------------------------------------

게임서버 DB저장

DB저장은 비동기로 이뤄지고, 데이터가 바뀔때마다 DB에 저장한다.

DB저장 순서는 완벽하게 맞아야하므로, 스레드 하나로 가는것을 권장.

두개이상으로 가고자한다면 물리적인 분리가 되어야 한다.

--------------------------------------------------------------------

게임서버 성능

단순히 하나의 지표로 판단할수 없음.

1. 코드차원에서의 성능


2. DB저장 능력
	
	내 코드가 버텨도 DB가 버티지 못한다면 어쩔수없이 동접자를 낮춤.


3. 네트워크 트래픽
	
	성능이 좋지만 네트워크 트래픽이 과해지는 경우.. (비용 증가)
	IDC센터의 기업하나도 3~40GB이기 때문에 7천명을 버텨도
	서버군마다 트래픽이 4GB씩 나온다면 회사가 망할지도 모름



--------------------------------------------------------------------

게임서버에서 오류 상황

MMO서버코드는 매우 방대하므로 단순히 눈으로 찾는것은 불가능.

....................................................................

배열 오버플로우

Crash나지않고 엉뚱한값이 수정되므로 굉장히 찾기 힘든 오류가 된다.
(또는 클래스의 가상함수 포인터 메모리공간을 건드릴 수있음)

....................................................................

동적할당 에러

동적할당한 메모리를 잘못 사용하는 경우 메모리 해제시 예외발생.

이 예외는 malloc이나 free가 아닌 heap에서 발생시켜준다. 
(호출스택에도 나타남)

--------------------------------------------------------------------

에코서버 예제 - 배열사용

관리하는 데이터만 가지고 플레이어를 대상으로 Lock을 없애는 것이 목표.

이제 메모리 참조오류는 나지않지만, 여러 스레드가 접근하여 write하므로
엉뚱한데이터가 로직처리될 가능성이 있음.

--------------------------------------------------------------------

Player State

플레이어에 대해서는 Update에서만 권한을 가진다.
이플레이어에다가 상태를 넣는다.

ON_STATE_NONE		Empty			(Accept 삽입가능)
ON_STATE_CONNECT	접속 후 플레이 대기상태	(Accept에서 사용중)
ON_STATE_LOGIN		플레이중인 상태		(Update로 넘어온상태)

......................................................................

State는 단방향 설계

무조건 단방향으로 설계되어야 한다


무조건 단방향으로 설계되어야 한다.

NONE 	 	> CONNECT	Accept
CONNECT		> LOGIN		Update
LOGOUT	 	> NONE		Update

.......................................................................


State가 누락된 경우

None > CONNECT > LOGIN (정상적인 상황)
그런데 곧바로 AcceptThread에서 CONNECT없이 LOGIN된다면?

동기화의 문제는 없지만 설계상문제.
미리 준비해야 할 작업(맵에 push, sector에 알리기, 아이템로딩 등) X


------------------------------------------------------------------------

WaitLogOut변수

종료 후 플레이어를 삭제하는것은 UpdateThread가 해야한다.
요청은 누구든지 할수있는 상황이어야 하고, 이는 요청하는 쪽에서 전달.

따라서 WaitLogOut이라는 변수를 두고, 체크

최종적으로 NONE상태로 바꾸는것은 Update가 해줌.
WaitLogOut변수는 어디서든 건드릴 수 있음.

------------------------------------------------------------------------

예제의 최종적인 형태

Updatethread에서 Lock이 없어졌고, 접속상태를 UpdateThread에서 처리.
(하단에서 일괄처리)

게임서버 라이브러리가 아니더라도 해당방식은 가끔 쓰인다.



장점

Lock의과정, Lock오버헤드, 컨텐츠오버헤드, 동기화 실수 등의 문제가없음
(동기화 자체가 나쁘다거나, 동기화객체가 많다고 해서 성능이 떨어지는것 X)
중요한것은 경합의 유무.



단점

상단부에 내 스레드를 끌어오는 작업의 루프,
중단부에 로직에 대한 루프,
하단부에서는 내 상태에서 나가는 애들에 대한 루프로

스레드당 세개의 루프가 돌게된다.
(진입 - 처리 - 나가기)

------------------------------------------------------------------------

기타 다른 로직


NewSession()

이곳에서 Player에 대한 상황을 넣기위해 비어있는 State를 찾아 셋팅.
그리고 .OnStateConnect를 변경.

이 변경은 최하단부에서 이루어지고, 끝까지 반복문 로직만 돌게된다.
스택에 별도 Index를 보관하여 사용하여 개선.


------------------------------------------------------------------------

세션 삭제

accept스레드에서는flag만 체크.
(accept스레드에서 지우면 Update스레드에서 쓰고있을지 모르므로 위험)

Update스레드에서 삭제하는 로직까지 포함한다면,

1. 상태끌어오기 
2. 원래 하던일(Send/Recv등 서버 IO처리)
3. 삭제하는 로직

으로 부하가 많이 걸리게된다.
Release라는 작업으로 부하가 커진다면 별도의 스레드로 뺄 수도 있음.

------------------------------------------------------------------------

별도의 DeleteSession 스레드 마련


이 경우는 체크된 객체를 마냥 삭제하는것이 아니라 별도의 상태를 마련해야한다.

현재는 UpdateThread가 Player를 단독으로 쓰고있으므로 직접 삭제해도 상관없음.
(flag는 셋팅이됐는데 따로 스레드가 나왔다면 다른쪽에서 사용중일 수 있다.)

Release라는 Thread가 나왔다면 Release라는 상태가 나와야 한다.
flagLogOut을 확인하여 전이시켜주면, 해당스레드에서 알아서 처리.

------------------------------------------------------------------------

UpdateThread

상태체크, 실질적으로 삭제하는 파트.

Connect상태면 UpdateThread로 보내고 이를 UpdateThread가 받아들인다.
이후 필요한 초기화작업(DB로딩)을 완료한 후 로딩된데이터 셋팅.

컨텐츠 작업들은 UpdateThread에서 진행한다.

------------------------------------------------------------------------

많은 if문과 for문으로 인한 성능


서버입장에서는 거의 느껴지지않음.

서버로직에서 UpdateThread프레임을 제한없이 4~5천번 돌린다면 CPU약간차지.
하지만 실제 프레임은 빨라야 100, FPS같은 경우도 4~50이면 충분하다.

따라서 이같은 상황을 성능하락으로 문제삼지않아도된다.


------------------------------------------------------------------------

Stack vs Queue

캐시히트로 인해 스택이 더 가볍고 빠름.
잘못만들어 졌을때는 스택에서 더 문제가 많이 남.

따라서 순서가필요없다면 스택을 사용

------------------------------------------------------------------------


