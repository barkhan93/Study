-------------------------------------------------------------------

동기-비동기 / 블락-논블락

비동기는 즉시 리턴후 백그라운드에서 작업
동기는 함수가 작업을 완료할때까지 기다림

block은 해당일을 할수 없을때 블락 여부를 뜻함.

동기는 블락/논블락이 가능하지만,
비동기가 되려면 논블락이어야한다.


-------------------------------------------------------------------

Overlapped Model

Overlapped이라는 표현은 MS가 비동기 입출력의 이름으로 정한 이름.
본디 고성능 파일입출력을 위해 제공하기위해 만들어졌다.

이를 소켓 입출력에도 사용할수 있게 만든것이 Overlapped소켓.

동기 - 커널쪽에서 작업, 리턴되면 해당작업의 결과로 사이즈를 알려줌
비동기 - 커널쪽에서 작업, 요청만 하고 빠진다.



-------------------------------------------------------------------

WSA_IO_PENDING

WSAGetLastError()의 오류코드로, WSA_IO_PENDING인 경우
OverlappedIO(비동기 요청)이 성공적으로 완료되었음을 의미한다.

Asyncselct 이후(포함) 모델들은 모두 Non-block이다.

WSAEWOULDBLOCK은 더이상 사용하지않는다.

-------------------------------------------------------------------

AsyncSelect는 WindowsMessage로, main thread기반(싱글스레드)으로
돌수밖에 없기 때문에 MS에서도 권장하지않음.

-------------------------------------------------------------------

EventSelect

EventSelect는 소켓하나당 Evenet를 등록시켜 소켓으로 signal이 오면,
WaitFor을 통해 signal을 확인하여 작업한다.

Select와 마찬가지로 소켓이 64개제한.
서버쪽에서 쓸일이 없으며, 클라쪽에서는 권장.


-------------------------------------------------------------------

Overlapped Model - EventSelect

Event방식은 쓰기가 번잡스럽기 때문에 잘 사용하지않음.

1. 비동기 입출력생성, WSACreateEvent로 대응되는 이벤트 객체생성.
 - 소켓당 이벤트 하나.

2. 비동기 입출력을 지원하는 소켓함수 호출(WSASend / WSARecv)
 - 이때 인자로 들어갈 WSAOVERLAPPED구조체의 hEvent에 Event핸들값 전달
 - 비동기 입출력 작업이 곧바로 수행완료 되지않은 경우 오류리턴

3. WSAWaitForMultipleEvents()로 기다림


단, 우리에게는 signal만이 전달되기 때문에 WSAGetOverlappedResult로 알아냄(Send인지 Recv인지는 이벤트 객체로 구분)

WSAGetOverlappedResult

BOOL WSAAPI WSAGetOverlappedResult
(
  SOCKET          s,		
  LPWSAOVERLAPPED lpOverlapped,		
  LPDWORD         lpcbTransfer,		// 작업이 얼마만큼 됐는가?		
  BOOL            fWait,		// 작업 미완료 시 블락 여부
  LPDWORD         lpdwFlags		// 
);

-------------------------------------------------------------------

EventSelect가 서버에 적합하지않은 이유

 - Event객체를 Send/Recv로 나눠 추가적으로 관리해야함
 - Event Signal이 와도 누구껀지 알수가없음 (모든소켓당 Event할당 불가)
 - WaitforMultipleEvent는 소켓이 64개로 제한
(64개씩 스레드를 끊는것도 이상한 구조)

-------------------------------------------------------------------

Overlapped Model - Completion Routine

소켓입출력 작업이 완료되면, 등록해둔 함수를 자동으로 호출

운영체제가 호출하게되는 함수를 콜백이라고 한다.
이를 특별히 Overlapped모델에서는 완료루틴이라고 한다.

단, 우리스레드에서 기회를 줘야 호출이 가능
커널이 마음대로 호출하는것은 있을 수 없는 일
이 때문에 제한이 있다는 단점존재

-------------------------------------------------------------------

Overlapped Model - Completion Routine 진행순서

1. I/O요청(비동기 I/O함수 호출)
2. 스레드는 alertable wait진입 (주기적으로 확인해야함)
3. 비동기 입출력이 완료되면 APC큐에 결과 저장
4. 비동기 IO함수를 호출한 스레드가 alertable wait상태면 APC큐에 저장된
함수 포인터를 참조하여 해당함수 호출

5. 완료루틴 호출이 끝나면 alertable wait상태에서 빠져나온다.

스레드가 비동기 입출력의 결과를 확인하기 위해서는 계속 alertable wait진입

-------------------------------------------------------------------

Overlapped Model - Completion Routine 설명

완료된 작업을 APC큐에 넣어주고, 들어온것들을 확인하면서
콜백함수를 호출시키는 형태이다.

콜백함수를 윈도우가 임의로 호출시키는것은 있어서는 안되는 일.
완료통지에 대한 함수호출은 내 스레드안에서 호출.

따라서 A스레드에서 IO를 요청 후, 완료이전에 Thread가 파괴되면 I/O는 끝남

-------------------------------------------------------------------

I/O RequestPacket

IO라는 단위는 관리자체가 thread이다.
File read/Write, Socket Send/Recv와 같은 IO작업은 모두 Thread에서 관리
입출력에 대한 I/O RequestPacket이라는 목록이 스레드에 붙어 내부에서관리.


I/O요청 패킷은 windows드라이버 모델 및 windows 장치 드라이버가 서로 통신
하고 운영체제와 통신하는 데 사용되는 커널모드 구조이다.

이는 I/O요청을 설명하는 데이터 구조이며, 
I/O요청 디스크립터또는 이와 유사한것으로 간주할 수 있다.

-------------------------------------------------------------------

APC 큐

APC큐는 작업완료를 쌓아놓는 역할이며, thread마다 존재.

시스템에서 APC를 많이 사용하며, APC큐는 스택이 아니라 해당 thread커널
객체에 큐가 붙어있는 형태로 존재.
(TLS역시 마찬가지)

-------------------------------------------------------------------

APC 큐 사용

우리가 직접적으로 큐를 확인하여 Deque하지는 않으나
APC큐를 확인하여 함수를 호출할 수 있는 시간을 부여해야한다.
(Alertable Wait)
이는 마치 인터럽트와 같은 개념이다.

-------------------------------------------------------------------

Alertable Wait

비동기 IO를 윟나 특별한 대기상태.
스레드가 이 상태에 있어야만 완료루틴이 호출 될 수 있다.

Alertable Wait역시 block당하러 가는것으로, 새로운형태의 wait이 아니다.
단 APC큐에 뭔가 일이 있다면 CPU가 그곳에 사용될 것.

-------------------------------------------------------------------

WSAWaitForMultipleEvents()의 마지막인자에 TRUE를 넣을경우 
alertable wait상태가 된다.

-------------------------------------------------------------------

alertable wait상태로 만드는 함수

WaitFor..Ex, SleepEx(), WSAWaitForMultipleEvents()등이 존재.
뒤에 Ex가 붙는 형태이다.

-------------------------------------------------------------------

스레드간 JOP을 던질때 사용하는 방법

1. 직접만든 큐 (polling방식)
2. APC큐 (alertable Wait상태를 확인)
3. IOCP사용

셋의 성능평가는 거의 체감되지않음.

-------------------------------------------------------------------

Completion Routine의 장점

OVERLAPPED* 를 뱉어주기 때문에, signal만을 주는 Event방식보다는 낫다.

-------------------------------------------------------------------

Completion Routine의 단점

요청한 스레드의 APC큐로 들어온다.
하나의 스레드에서 처리하는 구조이므로 병렬처리가 불가능하다.
(유저별로 스레드를 나누면 가능하지만.. 이렇게 할수 없으므로)


-------------------------------------------------------------------

Overlapped Model - 파일 입출력

파일비동기 작업의 경우 
OVERALPPEDIO구조체에 offset을 직접 계산하여 요청해야한다.

반대로 WSAOVERLAPPED(소켓)에서는 덮어쓰지않는다.

-------------------------------------------------------------------

Overlaeppd모델의 공통절차

1. socket()함수로 소켓생성
2. 비동기 입출력을 지원하는 소켓함수 사용가능
(WSARecv() ,WSARecvFrom(), WSASend, WSASendTo()

3. 운영체제가 IO작업완료를 통지

OVERLAPPED I/O에서는 모든소켓을 대상으로 Recv 대기상태여야 함.

-------------------------------------------------------------------

AcceptEx()

백로그 큐에 소켓을 만들어 연결시킨다음 리턴되는 구조.
AcceptEx()미리 소켓을 준비하여 등록시킨다.
Accept()를 비동기로 가겠다는 의미.

Accept()보다 1.5배정도의 성능향상을 볼것이지만, 구조복잡해지고
Accept()는 고성능으로 낼 가치가 없기때문에 사용하지않음.

Accept TPS는 최소 5천이상으로 나옴

-------------------------------------------------------------------

Transmitfile()

소켓조차 재활용하는 방식으로, closesocket을 하지않겠다는 것.

-------------------------------------------------------------------

WSAOVERLAPPED

typedef struct _WSAOVERLAPPED 
{
  DWORD    Internal;
  DWORD    InternalHigh;
  DWORD    Offset;
  DWORD    OffsetHigh;
  WSAEVENT hEvent;
} WSAOVERLAPPED, *LPWSAOVERLAPPED;



비동기 입출력을 위한 정보를 운영체제에 전달하거나, 운영체제가 비동기
입출력 결과를 우리에게 알려줄때 사용하는 작업의 단위이다.

Send/Recv를 같이 한다면 2개가 필요하다.
완료통지가 오기전까지 해당변수를 변경하거나 삭제해서는 안된다.

1~4변수는 단순히 초기화만 해주면 된다.

-------------------------------------------------------------------

OVERLAPPED 구조체 유의사항


OVERLAPPED 구조체 전달 자체가 비동기IO로 진행해달라는 요청이다.
동기 입출력이 됐다면 인자는 성공값을 뱉는다.

OVERLAPPED 구조체는 무조건 보존해야하며, 전달하는 BUF는 리턴되면 끝.



-------------------------------------------------------------------

WSASend, WSARecv

여기저기 흩어진 메모리 버퍼들을 하나로 등록할수 있게끔 지원한다.
하나의 버퍼만 사용할때는 비교하면 당연히 성능이 떨어지나,
버퍼 개수에 비례하여 성능이 떨어지지는 않음.


LPWSAOVERLAPPED

OverlappedIO의 flag역할을 한다. 


LPWSAOVERLAPPED_COMPLETION_ROUTINE 

완료루틴 방식을 사용할때만 세팅한다.
LPWSAOVERLAPPED보다 우선순위가 높다.
이 매개변수가 NULL이 아니라면 WSAOVEERLAPPED구조체의 Event는 사용X

-------------------------------------------------------------------

Accpet는 별도 스레드로 처리하고,
ListenSocket은 블락소켓으로 둔다.

-------------------------------------------------------------------

I/O Completion Port (IOCP)

IOCP는 소켓모델이지만, 실체는 하나의 Queue.
소켓I/O뿐 아니라 FILE I/O, threadPool의 개념으로 사용해도된다.

-------------------------------------------------------------------


IOCP의 장점

1. IOCP핸들만 가지고있다면 완료통지 받을 수 있음.
2. OVERLAPPED포인터와 Completion Key가 제공됨
3. WorkerThread를 제어할 수 있음.
4. stack방식으로 스레드를 깨움. (캐시히트)

-------------------------------------------------------------------

APC Queue VS Completion port


생성/파괴

APC큐는 스레드마다 자동 생성/파괴된다. 개발자 제어 불가.
IOCP 생성 : CreateIoCompletionPort(), 파괴 : CloseHandle()


접근제어

APC Q를 소유한 스레드만 확인 가능
IOCP핸들만 가지고있다면 접근이 가능.


비동기 입출력 처리방법

APC Q는 alertable wait상태에 진입.
IOCP는 GetQueuedCompletionStatus()호출.

-------------------------------------------------------------------

IOCP 동작원리

1. 비동기IO 요청
2. GQCS함수로 IOCP감시. (디폴트는 block)
3. 작업 완료시 IOCP에 결과저장
4. WorkerThread중 하나를 깨운다.

-------------------------------------------------------------------

CreateIoCompletionPort

IOCP를 생성 / 이미 만들어진 IOCP에 추가적인 핸들을 등록하는 함수

생성 시 _IOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);
등록 시 - CreateIoCompletionPort(Socket, IOCP, &Session, 0);

-------------------------------------------------------------------

IOCP - Completion Key

Event는 Signal만을 알려줌
Completion Routine의 APC큐는 OVERLAPPED 구조체 포인터를 전달.

ICOP는 하나의 핸들(소켓)당 Completion Key가 존재하고, 이를 자유롭게사용
(보통은 세션포인터를 넣는다)

-------------------------------------------------------------------

NumberOfConcurrentThreads

동시에 실행 할 수 있는 작업자 스레드의 개수.
0인경우 논리 CPU개수로 설정된다. (듀얼코어 하이퍼스레딩 = 4)

단, running중이던 스레드가 block됐다가 다시 Running된다면,
이수치를 넘을 수있다.

한번 만들어놓은경우 변경이 불가능하다.

-------------------------------------------------------------------

IOCP - WorkerThread개수 조절

로직스레드가 매우 바쁜경우 내 코어개수에서 -1. (항시 돌것이기 때문)
워커스레드 내부에서 블락이 많을 경우, Workerthread를 많이 만들면 성능향상

로그인서버와 같이 DB작업이 포함된 경우 WorkerThread를 3~40개만들면 
확실한 효과를 볼 수 있음.

최악의 경우 모든 WorkerThread가 깰수있으나, 역효과가 나더라도 
이 방법이 나음.

-------------------------------------------------------------------

게임서버 Workerthread 개수

일반적인 게임서버의 경우 WorkerThread내부에서 Proc를 돌리지않기 때문에,
Send/Recv를 제외한다면 Block걸릴일은 거의 없다.

설정파일로 빼야하는 항목이다.

-------------------------------------------------------------------

스레드풀 방식 Event 방식 vs IOCP 활용

1. IOCP는 stack방식으로 스레드 깨울수있음.
2. IOCP는 Running스레드 제어 가능
3. Event는 여러개의 Signal이와도 인식불가.
(JOP이 쌓여도 하나의 스레드만 깨어나서 일을 처리)


-------------------------------------------------------------------

GQCS사용시 주의할 점

호출 전에 transferred, CompletionKey, OVERLAPPED 셋은 반드시 초기화.
GQCS의 반환값은 어디서 실패했는지 알려주지 않음.


1. OVERLAPPED == NULL

IOCP자체의 문제, GQCS의 TimeOut초과


2. Transferred = 0

클라로부터 종료요청(Recv 0)


3. 세개인자 모두 NULL

우리가 PQCS로 쏴줄 종료요청.
보통 TimeOut을 INFINITE값으로 넣기 때문이다.

-------------------------------------------------------------------

PQCS

작업이 완료된것처럼 큐에 꽂아준다.
IOCP를 스레드풀로 사용할때, 또는 Queue에 작업을 큐잉하고 
이벤트를 기다리는 형태를 사용하고 싶을 떄 사용.

단, IOCP 큐자체가 Non-pagedPool Memory를 사용하므로 주의.

워커스레드 종료시 사용하기도 한다.

-------------------------------------------------------------------

GQCSEx

alertableWait상태로 진입하는 기능에 더해, 여러개의 완료통지를
한번에 뽑는것을 가능하게 한다.

GQCS의 호출량을 줄일 수 있겠다.

단, 소켓모델로서 IOCP는 병렬처리를 위해 사용하는것으로,
한번에 뽑아가는것이 전혀 의미가 없는 행위이다. 

-------------------------------------------------------------------

GQCSEx를 고려할 대상

1. 송수신 완료통지가 아닌 Jop에 대한 Queue로만 활용 시
2. 우리가 준비한 RunningThread 개수 이상으로 완료작업이 쏟아져나올 때.


사실 WorkerThread가 여러개 있는데도 감당하지 못할 정도로 완료통지가
쏟아지는 경우는 거의 존재하지 않는다.

단, WorkerThread가 하나인 경우는 라이브서비스에서도 많이 존재한다.

-------------------------------------------------------------------

GQCSEx 사용법

OVERLAPPED_ENTRY라는 구조체 포인터를 Out형식 파라미터로 받고, 
뒤이어 Count가 들어간다.

이는 곳 OVERLAPPED_ENTRY라는 구조체 포인터를 배열로 선언하여
파라미터로 넣어줄 경우 완료통지를 한번에 뽑아준다는 얘기이다.
(기존 GQCS는 하나씩만 가능했다)

ulNumEntriesRemoved에는 몇개의 완료가 뽑혔는지 들어온다.

-------------------------------------------------------------------

대중적인 게임 서버 구조

게임이란 특성상 유기적으로 연결된 것이 많으므로,
WorkerThread에서 모든일을 처리하는것은 적합하지않다.(동기화이슈)

따라서 별도의 단일 컨텐츠 스레드(Update)로 빼는것이 일반적이다.


WorkerThread - I/O담당
UpdateThread - 로직스레드
SendThread   - Send담당

동기화 경합지점을 최소화 시켜 WorkerThread에서 직접적으로 처리하는것이
IOCP의 이상적인 목적이므로, 위 경우는 관점에따라 IOCP를 잘못사용하는것

-------------------------------------------------------------------

대중적인 게임서버 구조가 이렇게 된 이유

1. Send를 1회로 제한해야한다고 아는 잘못된 이유들
2. Send를 1회로 제한하기 위해 별도의 SendThread등장

오버랩I/O를 사용하지만, Send용 링버퍼에 데이터를 쌓아놓고 SendThread에 Send를 1회로 제한한다.

-------------------------------------------------------------------

Send를 1회로 제한하는 [잘못된] 이유


1. Send를 할때마다 요청한 크기보다 작게 반환되면 돌이킬 수 없음.

-> WinSock에서는 FILE I/O와 달리 Send가 중첩되어도 반드시 순서를 지켜주며
누락되는 경우도 모두 대비되어 있다.


2. 작업완료에 대한 순서보장이 되지않는다.

-> 작업의 순서는 보장되지만 완료통지의 순서는 보장되지않는다.


결국 Send를 여러번 하는것은 기능적으로 아무런 문제가 없음

-------------------------------------------------------------------

그럼에도 Send를 1회로 제한하는 이유

구조가 복잡해지고 성능이 떨어지기 때문.
Send를 하고싶을때마다 한다면 Overlapped구조체가 나와야 한다.

-------------------------------------------------------------------

Recv를 1회로 제한하는 이유

Recv역시 중첩으로 걸어놔도 기능적으로 문제가 없으나, 
Send와 마찬가지로 장점이 없음.

완료통지의 순서는 지켜줄 것이나 어떤스레드가 먼저 작업을 마칠지
우리는 알수없음

그리고 Recv온 메시지를 처리하기전에 WSARecv를 중첩으로 건다면,
순식간에 수신버퍼와 Recv링버퍼가 모두 차버릴수있음.

-------------------------------------------------------------------

Send/Recv 중첩으로 걸때 걱정하는것?

Recv/Send의 반환값이 우리가 요청한 것보다 적게 반환이된 경우는 절대없다.

단 한가지 예외로, 소켓연결이 끊겼을 경우는 요청한 값 미만으로 올수있음.
이 경우 어차피 끊을 대상이므로 고려사항 X

-------------------------------------------------------------------

PageLock

WSASend, WSARecv를 할때 완료통지가 오기전까지 
버퍼(힙)와 오버랩구조체가 보존되어야 한다.

Overlapped I/O는 커널쪽에서 카피를 하는 행위.

이때 Recv를 걸어놓은 버퍼(힙)이 PageOut되는 것을 막기위해 락을건다.

-------------------------------------------------------------------

비동기 I/O의 작동

반환값이 WSA_IO_PENDING인 경우에만 Overlapped I/O로 작동된 것.
반환이 성공했다면 동기입출력을 통해 Send/Recv가 성공한 것이다.

비동기I/O는 지금당장 일을 하지못할때만 전환된다.

WSASend - 소켓버퍼가 가득 찬 경우 (송신버퍼 0으로 만들면 비동기)
WSARecv - 소켓버퍼로 부터 받을 데이터가 없는 경우

-------------------------------------------------------------------

WSANOBUF Error

모든 메모리에 PageLock을 걸면 가상메모리 구조 의미 X
따라서 일정 용량이상을 PageLock을 걸지 못하도록 한계치가 정해져있음

이 한계치를 넘어서면 WSANOBUFS에러가 발생
실제로 경험한 사례는 극히 드물지만, 모든 서적에 언급됨

WSANOBUF에러가 발생한경우 OverlappedI/O는 실패하고,
보통 검은화면이 뜨면서 아무것도 제어할 수 없는 상태가 됨.

일반적으로 Recv/Send를 1회로 제한하고, TPS가 안정적이고, 
IOCP를 잘 사용했다면 일어나지않는다.

(TIME_WAIT이 남는것도 Non-Paged메모리를 사용함)

-------------------------------------------------------------------

WSANOBUF Error 방지

1. 버퍼를 페이지 단위로 간다.

우리는 링버퍼를 사용하므로 불가능한 방법.
링버퍼는 4KB잡는다고 해도 시작점인지 알수 없고, 이를 맞추기위해
힙구조를 포기하는것은 좋지않음.


2. 동접자를 낮추거나, 버퍼크기를 줄인다.

링버퍼가 만바이트라면, 페이지를 3개 사용하고 있을 것.


3. 물리메모리 자체를 늘리는 것

-------------------------------------------------------------------

IOCP에서 PageLock을 줄이기 위한방법

GQCS에서 뽑지 않는다고 하여 락이 걸리지 않는 것이 아니라,
오버랩IO가 끝나고 완료통지가 넘어가야 락이 풀리게된다.

따라서 Recv는 항시 걸려있어야 하므로 오버랩IO로 5천명이 걸려있다면,
[5000 * Recv링버퍼 크기]만큼 락이 걸리게된다.

만약 Send를 1회로 제한하지않고 여러번 건다면 역시 락이 걸릴 것.

-------------------------------------------------------------------

Non-Paged Pool Memory란?

애초부터 물리메모리에 상주하며, 절대 Page-Out되지않는 메모리.
항상 메모리에 상주하므로 접근속도가 빠르다.

64비트 운영체제에서 최대 128GB의 논페이지드 메모리사용가능.
(보통 물리메모리의 1/4가 한계)

-------------------------------------------------------------------

Non-Paged Pool은 어디서 사용?

1. 드라이버와 같은 커널모드 컴포넌트 
(윈속, tcpip.sys와같은 프로토콜 드라이버)

2. 소켓생성시 정보를 저장하기위한 용도로 사용

3. 소켓이 특정 주소로 바인딩되면, 
TCP/IP스택은 로컬주소 정보저장을 위해 사용

4. Overlapped I/O연산시 IRP(I/O request packet)를 발생시키며,
약 500byte Non-Paged Memory할당


-------------------------------------------------------------------

Non-PagedPool이 부족할때 나타나는 증상은?

1. 운이 좋을 경우 윈속함수가 WSANOBUFS에러 발생
2. 시스템에러로 손상되어 아무것도 제어하지못하는 검은화면

-------------------------------------------------------------------

이밖의 Non-PagedPool 특징

Non-PagedPool의 정리는 C#의 Garbage Collecter와 비슷하다.
Non-Paged메모리를 반환해도 즉시반환되지않고 한박자 늦게 정리한다.

PoolMon(NonPagedPool모니터링 프로그램)으로 확인이 가능.


-------------------------------------------------------------------


Zero Byte Recv

MMO서버에서 리소스의 소비를 줄이는 방식으로, 우리는 쓰지않으나
MS의 Windows NetWork Programming에서 언급되므로 기억해둔다.

ZeroByteRecv는 일부러 Recv의 WSABUF Len을 으로 넣어서
완료통지에서 transferred가 0으로 떨어지게한다.


-------------------------------------------------------------------

Zero Byte Recv 동작형태

OVERLAPPED I/O사용시 커널 내부에서는 언제 Recv를 할지모름.(상시 걸려있음)
이때 완료통지가 온다면, 수신버퍼에 들어온것으로 
우리쪽 링버퍼로 Copy하지않은 형태이다.

이때 Recv완료통지 시 Recv를 걸면 동기로 처리될 것이다.
이는마치 AsyncSelect에서 Read를 걸어두는것과 같음)

ZeroByteRecv는 ZeroCopy와 달리 수신버퍼를 0으로 만드는것이 아니라, 
WSARecv의 길이 인자로 0을 넣겠다는 의미이다.(WSABuf len 0)

-------------------------------------------------------------------

Zero Byte Recv를 쓰는 이유

1. IOCP구조를 가져가되 NonPagedPool의 리소스할당이 걱정됨

- Recv링버퍼의 크기가 매우 큰경우 NonPaged메모리 사용량이 많기때문



2. 동기IO를 사용하고싶음 

- 어차피 비동기든 동기든 CPU소모량은 같음.
일반적인 게임서버에서  WorkerThread가 바쁘지않으므로 동기화사용.
(어떤게 더 좋을지 테스트를 거쳐 검증해볼 것)


3. Recv의 상황을 바로바로 파악하고 싶음


-------------------------------------------------------------------

Zero Byte Recv가 선호되지 않는 이유

Recv결과값이 0으로 떨어진다고 하여 종료처리를 할수없게되므로 
구조가 매우 복잡해짐

-------------------------------------------------------------------

완료통지 기준

WSAOVERLAPPED의 Overlapped I/O는, 동기 비동기 가리지않고 완료통지가온다.
IOCP내부에서는 동기/비동기를 굳이 구분하지않는다.

모든 마무리를 WorkerThread쪽에서 하도록 코드를 단일화 하기때문.
성능을 위해(쓰레드가 깨니까) 동기작업 완료의 통지를 받지않게 할수있음

via에서 언급된다. 단, 구조가 좋지않으므로 잘 사용하지않는다.
(이렇게까지 하는경우는 잘없음)

-------------------------------------------------------------------

ZeroCopy

본디 우리가 데이터를 받거나 보내고자한다면, 3번의 Copy를 거친다.

[TCP스택 - 커널 송신버퍼 - 서버SendQ - 로직 직렬화버퍼]

제로카피는 로직Packet에 있는 데이터를 TCP스택으로 한번에 보내자는 의미.
송수신버퍼의 크기조절은 요청의 느낌이었으나, 
Overlapped I/O에서는 그대로 반영된다.

-------------------------------------------------------------------

송신버퍼가 0이 된 경우

WSASend는 100% WSA_IO_PENDING상태에 빠지게됨.
WSASend요청한 버퍼는 페이지 락이 걸리고 TCP스택에서 직접 Copy한다.

(이는 우리메모리가 송신버퍼 역할을 하게 된 것.)

WSABUF로 여기저기 널려있는 힙메모리를 모아서 넣었으므로,
해당 메모리가 속한 페이지는 모두 Lock이 걸릴 것이다.

-------------------------------------------------------------------

ZeroCopy vs Zero ByteRecv


ZeroByteRecv는 Non-PagedMemory를 아끼기위해 비동기를 피하는 것

ZeroCopy는 Copy를 줄이기위해(서버속도 향상) 100% 비동기를 발생시킨다.

-------------------------------------------------------------------

ZeroCopy - 링버퍼 없애기

링버퍼를 없애는것은 난이도가 너무 높아지기 때문에 진행하지않음.

-------------------------------------------------------------------

IOCP에서의 Send/Recv

Send - 대부분 송신버퍼는 여유가있을 것이므로 동기로 작동됨
Recv - 대부분 수신버퍼는 비어있을 것이므로 비동기로 작동됨

-------------------------------------------------------------------

송수신 버퍼의 사이즈 조절(요청)

- 송/수신 버퍼는 비동기환경에서는 0으로 만들 수있다.
- 단, 수신버퍼사이즈를 0으로 만드는 것은 여러가지 문제.
(커널에서 알아서 똑똑하게 처리함. 0 비권장)

   문제 1. [Recv완료통지 -> 로직처리 -> Recv검]
	TCP는 Recv공백기간동안 패킷이 모두 버려지게됨
	UDP는 모든패킷이 버려짐

위문제는 문서상(https://crmerry.tistory.com/28?category=1031711참조)
존재하는것으로 실제로는 다르게 동작한다.

수신버퍼를 0으로 만들어도 IOPENDING이 일어나지않으며,
내부에서 다시금 수신버퍼를 늘려 Copy로 들어간다.
(근데 getsockopt해도 수신버퍼 사이즈는 계속 0으로나오게됨)

	
번외로, 버퍼조절없이 WSARecv인자로 0을 넣어버리면 내부 수신버퍼를
우리의 링버퍼와 같이 사용할수있음(ZeroByteRecv)


-------------------------------------------------------------------

Seession

세션은 보존되어야 할 대상. 
송/수신 링버퍼가 들어가있다.

-------------------------------------------------------------------

끊김통지(Recv = 0)이후 종료처리


ex[Recv가 걸려있는 세션에서 Send 이후에 closesocket했다.]
	
	1. Send성공 완료통지 이후, Recv연결끊김 통지 (문제없음)
	2. Recv끊김통지 이후, Send성공 완료통지가 온다. (문제)

2번의 경우 끊김통지 이후 즉시 지울것이고,
소켓이 재사용되어 엉뚱한 세션이 Send성공 완료통지를 받을수있다.
이 경우 로직이 엉망진창으로 꼬이는 것이다.


어떤소켓이 끊겼다면 모든 I/O는 중단되므로, 
IOCP작업 자체에 뭔가 문제가 나는것은 아니나 컨텐츠 코드쪽에서 문제발생.

-------------------------------------------------------------------

closesocket시 컨텐츠 코드문제

1. 세션자체가 삭제되어 메모리 참조오류
2. socket값 재사용으로 인해 엉뚱한 세션으로의 로직처리

->따라서, 모든 IO가 끝났는지 판단한다음 세션을 지워야한다.

-----------------------------------------------------------------------

세션을 지우기 위한 방법.


1. 완료통지로 종료가 오더라도 삭제를 하지않고 대기시간을 가짐.


단점

하지만 종료통지 이후 찰나에 Send완료통지가 올것이므로,
길게 물고갈 이유도 없는데다가 여러 스레드중 동시에 두개가 깰수도있음.
(이경우 대기시간 가지는게 소용 X)

결론

재사용 가능성을 낮춰주지만 100%보장되는 방법은 아니다.
실제 라이브서비스에서도 많이 사용되긴한다. (비권장)




2. IO가 모두 끝났는지 코드로 직접확인

가장 확실하고 고전적인 방법으로, IO자체를 카운팅하여 0이될때 삭제한다.
멀티스레딩 환경이라면 당연히 인터락을 사용.

이 Count는 행위를하기전에 증가시키고,
행위가 끝난다음에 차감시켜야한다.

----------------------------------------------------------------------

AcceptThread를 닫고싶을 때

Listensocket을 Close해버리면된다.


----------------------------------------------------------------------

Send의 Movefront (사용완료 처리)

Send완료통지가 온다음 밀어야 할 것.
Send직후 바로 밀어버린다면 링버퍼 특성상 Enque될때 겹쳐질수있다.

----------------------------------------------------------------------

CloseSocket은 한번만 호출

I/O가 두번이므로, Closesocket은 한번만 해야한다.
이런 예외가없다면 재사용된 핸들이 끊김처리당할 수 있다.

----------------------------------------------------------------------

ShoutDown 의 사용

ShoutDown호출시 모든 데이터를 전송하고 FIN을 호출하게 된다.
리소스반환이 되지않으므로 소켓이 재할당 되지않을 것.

따라서 평소에는 shoutdown 으로 끊기준비를 하고, 
Release할때 Closesocket(끊기)하면 핸들재사용 문제를 간단히 해결가능.

----------------------------------------------------------------------

ShoutDown 단점
서버가 먼저끊어 서버에 남은 TIME_WAIT
클라쪽이 FIN을 주지않는다면 대기상태 (몇십초후 OS가 끊어주긴함)

따라서 우리는 LINGER옵션을 설정하여 RST를 쏘는것으로 간다.

----------------------------------------------------------------------

CancelIO

인자로 들아온 핸들에대해 스레드가 보류중인 모든 IO작업 취소

다른스레드의 I/O작업취소시 CancleloEx()함수 사용

----------------------------------------------------------------------

SendThread가 없을때 문제

WorkerThread가 아닌 전혀다른 외부에서 호출하여 IOCount를 증가시킬수있음

----------------------------------------------------------------------

IOCP vs Select

IOCP는 다양한 안전장치가 들어가야 하기때문에 엉터리로만들면
select보다 성능이 더 나오지않는다.

----------------------------------------------------------------------

Session Lock

어느스레드 에서든지 SendPacket이 호출가능하므로,
이는 언제든 Release가 될수있음을 의미한다.
따라서 락을 걸어 안정성 확보.

----------------------------------------------------------------------

SendThread를 사용하는 경우

SendThread를 사용하면 동기화부분을 간단하게 만들 수 있다.

----------------------------------------------------------------------

삽입/삭제 동기화문제 해결

1. 자료구조를 배열로 사용
2. 삽입/삭제를 같은곳에서 처리

이 경우 Accept구조도 바뀌어야 할 것.

단 IOCount가 물린상태에서 진행되기때문에 Release를 쓸일이 없고,
Session에 대한 동기화를 넣지않아도 문제가 일어나지않음

----------------------------------------------------------------------
 
계층 분리

[네트워크 소켓API / 네트워크 라이브러리 / 컨텐츠 파트]

세개로 나눌것인데, SessionID는 컨텐츠 파트에서 소켓과 같은 역할
컨텐츠 파트는 세션자체에 접근 불가

----------------------------------------------------------------------

Session ID

세션이 들어올때마다 ++해준다.
소켓값은 재사용되므로 SessionID로 사용금지

일반적인 네트워크 환경에서의 host는 네트워크에 연결된 장치,
p2p게임에서는 host는 서버를 의미한다.

host는 다양한 의미를 내포하므로 SessionID를 사용

----------------------------------------------------------------------

Session Find fail

컨텐츠쪽에서 실수할수 있으므로 서버를 죽여서는안된다.
단순히 return false

----------------------------------------------------------------------

OnRecv

헤더를제외하고 PayLoad만을 컨텐츠쪽에 전달
우리가 만드는것이 5,6계층, 7계층은 컨텐츠

----------------------------------------------------------------------

OnLeave

연결이 끊기고 IOCount가 0으로 떨어져 Release해야 하는 순간호출

----------------------------------------------------------------------

On..함수들

핸들링하고자하는 이벤트의 발생을 알려주는 역할.
네트워크 라이브러리에서 발생한 이벤트를 컨텐츠쪽에 알려주기 위함

----------------------------------------------------------------------

SendPacket(), DisConnect()

컨텐츠쪽에서 라이브러리로 요청하는함수.

(컨텐츠쪽에서는 라이브러리 관련 리소스에 접근불가)

----------------------------------------------------------------------

Session 동기화 이슈


1. 컨테이너 자체

Lock걸고 삽입/검색/삭제


2. Session내부 리소스

컨테이너 자체를 lock걸고 사용하면 동기화 이슈는 발생하지않음
단, 이경우는 병렬처리가 전혀되지않으므로, 멀티스레딩 의미없음

WorkerThread내부에서는 문제없으나 외부스레드에서 접근할때 문제
SendPacket()은 어디서든 호출이 가능하고, 바깥에서 지워질수 있음

----------------------------------------------------------------------



WorkerThread내부에서 Session요소 Lock



1. WorkerThread에서 동시접근 불허 

WorkerThread진입하자마자 Lock을걸면 내부에서 Send하면 또다시 Lock..
또한 Release시에도 Session에대한 Lock.

따라서 재귀락이 발생하므로 SRWLock(X) CriticalSection(0)
(IOCount가 0이되어야 Release하므로, 지워질걱정은 X)


2. WorkerThread에서 동시접근 허용(Release만 Lock)

다른쪽에서 요청하는것은 SendPacket() / Disconnect()
Workerthread안쪽에서는 어차피 IOCount가 0일때 Lock걸고 삭제

----------------------------------------------------------------------

멀티스레딩의 목적

WorkerThread를 여러 스레드로 만든이유는, 병렬처리를 위함이다.
한쪽에서 Send를 하고있어도 Recv가 가능해야한다.

WorkerThread자체에서 Lock을 걸어버리면 문제가 생기지는 않지만,
전혀 병렬처리가 되지않음

따라서 WorkerThread에서 Session을 사용할때는 
Lock없이도 문제가 없어야 한다.

(List자료구조에서 삽입/삭제는 락이 필요하므로 어쩔수없음)

----------------------------------------------------------------------

시도해볼 이중락 형태

list_Lock(검색) - SessionLock - list_Lock해제 - Session사용 

이방법은 실제로 아무도 사용하지않으며, 공부목적으로 시도한다.
이중락은 데드락의 위험을 가지고있기 때문이다.

----------------------------------------------------------------------

Session요소 동기화락을 거는 곳

WowrkerThread내부에서 완료통지를 위해 Session에 접근하는 상황에서는 X.

그외 세션을 사용하는곳에서 Find이후 요소락을 걸고 사용.


----------------------------------------------------------------------

IOCP에서는 생성/삭제 방식을 사용하지않음

1. New / delete 성능이슈
2. Session요소에 대해 깔끔한 동기화가 애매함
(대안으로는 삭제할 세션을 모았다가 한쪽에서 한방에 삭제)

수시로 생성/삭제 하는 방법은 너무 난해하다.
따라서 우리는 세션자체를 지우지않게끔 진행하고, (무조건 배열로가자는뜻X)
추가적으로 SessionLock까지 없애면 좋을 것이다.

----------------------------------------------------------------------

Disconnect()

비정상적인 메시지, 중복로그인 패스워드 등의 이유로 끊기 요청
연결을 끊는것으로, Release와는 다르다.

----------------------------------------------------------------------

ListenSocket 옵션 상속

기본적인 소켓옵션들은 대부분 listen에 걸어두면 상속된다.
LINGER, 버퍼사이즈 조절 모두 동일.(직접 테스트해봄)

----------------------------------------------------------------------

Send 1회로 제한

flag를 추가하여, 인터락으로 판단하여 WSASend를 1회로제한
Send들어가기전에 Flag를 바꿔주고, 완료통지가 오면 다시 바꾼다.

----------------------------------------------------------------------

SendQ.Enqueue의 중첩

SendPost에서 Send가 진행중인 경우라도, SendQ에 Enqueue하는것은 문제없음.

----------------------------------------------------------------------

SendQ.Enque의 중첩을 막는 이유

SendQ락을 믿고 하나의 Session대상으로 여러스레드가 Send해서는 안된다.
억지로 만들수는 있겠지만 이러한 구조는 쓰이지않음

1. 코드차원에서 동시접근 발생시 메모리 참조오류/예외가 발생할 수있음
2. 여러스레드에서 Send시, 어떤순서로 올지 전혀 보장되지 않기 때문이다.
(한스레드에서 보내는것은 정확히 보장)

(지금은 세션을 찾아 사용할떄 세션단위로 락걸기때문에 상관X)
(이후 락프리 구조적용시 락을 걸지않고 진행)

----------------------------------------------------------------------

IOCP 구조

IOCP구조는 굉장히 다양하고 정석이 존재하지않는다.
우리가 진행하는 프로젝트는  범용적인 네트워크 라이브러리 성격.
일반적인 구조보다 고달픈구조를 통해 공부목적을 위해 범용적인 구조로안감.

(왜 SendThread를 사용하는지, Session을 왜 이렇게 관리하지않는지...)

실무에서는 한가지 상황에 맞게끔 구조를 가져가기도함.

----------------------------------------------------------------------

Send() 속도

5000개의 소켓을 대상으로 루프내부에서 send를 호출한다면, 2~300m/s정도.
체감될 정도로 느린 속도이므로, 많은 인원에게 Send하는 코드는 존재X

공지같은 경우도 채널/방 분산으로 Send해주며, 많아도 몇백명 수준이다.

----------------------------------------------------------------------

스마트 포인터

스마트포인터 자체를 동적할당 하여 사용.
내부 RefCount변수 역시 동적할당 하여 공유.
스마트포인터는 1이상이어야만 유지.

----------------------------------------------------------------------

스마트 포인터방식으로 Session요소 동기화

스마트포인터는 누군가는 반드시 물고있어야 유지됨.

WSASend를 하면 Session포인터는 우리손에서 떠나게되고,
완료통지가 왔을때 Key값으로 해당 Sesison을 받는다.

따라서 중간에 Session이 사라지는 구간이 존재하므로,
RefCount가 0이되므로 이러한 방식은 적용이 불가능하다.

----------------------------------------------------------------------

IOCount방식으로 Session요소 동기화

동기화객체가 아닌  IOCount처럼 접근스레드 카운팅 방식으로 사용.
동기화 객체를 사용하는것보다 빨라지긴 했지만,
경합이 발생되지않는다면 똑같은 구조이므로 큰 이득이 없음.

----------------------------------------------------------------------








