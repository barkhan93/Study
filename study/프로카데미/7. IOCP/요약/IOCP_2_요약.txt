데이터를 보내는 도중 shutdown을 보내는 경우

Send쪽 완료통지는 떨어진다
Recv의 경우 어떻게 될지 예측불가

-------------------------------------------------------------------------

TIME_WAIT이 남은 경우

TCP입장에서 종료되지 못하고 남아있는것으로,
몇십초 가량이 지나면 OS가 알아서 정리한다.

이 정리 역시 Recv 0으로 완료통지가 오게된다.
TIME_WAIT이 남은 상태로 그냥 둔다는게 아주 말이안되는것은 아님.

-------------------------------------------------------------------------

TIME_WAIT이 남았을 경우 문제

리소스 문제도 있을 것이고, 중복 로그인 같은 경우
기존 접속 유저가 끊기지 않고 남아있게 될 것.

가능하다면 이러한상황은 만들지 않는게 좋기때문에 shutdown비권장

-------------------------------------------------------------------------

Cancel I/O

Recv를 건상태에서 TCP스택에 데이터가 들어와 내 송신버퍼에 복사하는 과정
에서 cancel I/O가 호출된다면 Transferred는 0이 떨어지지 않는다.

이 경우 로직에서 예외처리를 따로 해줘야하는 상황이다.

-------------------------------------------------------------------------

Send이후 곧바로 closesocket하면? 

상대방이 프로토콜 스택에 Send한 데이터를 모두 받았다고 가정하고,
이때 RST나 FIN이 오는 경우 해당 패킷을 먼저 처리한다. (데이터는 버려짐)

FIN/RST가 먼저 도착하는것이 아니라, 로직이 이렇게 처리된다.

-------------------------------------------------------------------------

가상함수로 (라이브러리 -> 컨텐츠쪽) 전달

네트워크 라이브러리는 빈 가상함수를 호출시키고,
컨텐츠 쪽에서는 알맹이를 채우면 간단하게 Callback이 구현됨.

-------------------------------------------------------------------------
-------------------------------------------------------------------------

일반적인 IOCP 모듈화

IOCP 클래스 - 실제 네트워크 파트
TCP  클래스 - IOCP클래스에 등록
USER 클래스 - TCP클래스를 상속하여 정의

-------------------------------------------------------------------------

일반적인 IOCP 모듈화 특징

Accept 전담클래스, TCP전담 클래스가 따로나와서
세션마다의 송수신, 송수신버퍼, 소켓, Send의 행위가 들어간다.

생성주체는 USER클래스이며,
IOCP클래스 내부에서는 우리가 상속받은 유저를 알수없으므로, 던져줘야함.

Accept클래스 -> 유저클래스 (상속하여 생성)
Accept클래스 -> IOCP클래스 (유저를 IOCP에 등록)

MyAccept에서 상속받아 알맹이를 채우면, Accpet()호출될때 우리쪽으로 전달.
여기서 유저를 생성하고, 해당포인터를 IOCP에 던진다.

-------------------------------------------------------------------------

TCP클래스

TCP클래스에 간단히 소켓, 송수신버퍼를 두고, 우리는 
TCP플레이어를 상속받아 player, Session등의 이름으로 포장한다.

Accept만 업로드하는 클래스를 MyAccept등의 이름으로 상속받아 기능확장.
TCP를 상속받은 플레이어를 등록시키면, Accept시 플레이어 생성
플레이어를 IOCP클래스에 던져주면 등록.

-------------------------------------------------------------------------

IOCP클래스


IOCP클래스에 TCP클래스를 등록하고, TCP포인터들을 관리.
TCP클래스를 상속받아 Session을 만들고, 이를 IOCP클래스에 등록

최종적으로는 IOCP클래스에 가상함수를 통해 우리쪽으로 전달

-------------------------------------------------------------------------

USER클래스

TCP클래스를 상속받아 USER클래스를 만들어 알맹이를 채움.
USER클래스에 대한 생성과 관리는 우리쪽에서 한다.

IOCP클래스는 TCP에 대한 포인터들을 관리.

-------------------------------------------------------------------------

Accept클래스 동작예시

Accept클래스 - 우리쪽에서 알맹이를 채워준다(Accept스레드 내장)
IOCP클래스 - TCP에 대한 포인터관리 및 처리. 가상함수를 통해 우리쪽에 전달
TCP클래스 - 상속받은 내용대로 실질적으로 생성하여 IOCP에 등록

이제 accept가 될때마다 TCP클래스에 실질적으로 생성되고, IOCP에 등록

-------------------------------------------------------------------------

일반적인 IOCP모듈화의 장단점

위와같이 일반적인 IOCP모듈화는 옛날방식으로, 세분화가 장점.

Accept는 Accept만을 진행하고,
TCP는 하나의 소켓대상으로 TCP통신을 전담한다.
IOCP는 WorkerThread에 대한 것을 전담한다.

-------------------------------------------------------------------------
-------------------------------------------------------------------------


네트워크 라이브러리 내부로 모두 통합시키는 방법

모듈화입장에서는 좋을 수 있으나, 노출이 된 형태임.

-------------------------------------------------------------------------

우리가 택할 방법

네트워크 라이브러리 내부로 모두 포함시키고, 외부에 노출X
세션역시 완전히 감추고, 컨텐츠쪽에서는 SessionID로 라이브러리에 요청

-------------------------------------------------------------------------
-------------------------------------------------------------------------

프라우드넷에서 일반 IOCP모듈 


stub이라는 가상함수만 존재하는 인터페이스 클래스를 둔다.

stub클래스 내부에서 우리가 정의한 메시지 에따라 Proc가 요소마다
가상함수로 껍데기가 만들어져있다. (가상함수형태)

USER클래스가 모두 Stub안에 들어가는 형태로 핸들러 역할을 하는 인터
페이스만 빼놓고 등록하는 형태이다.

-------------------------------------------------------------------------

프라우드넷의 RPC적용

프라우드넷은 엔진입장이므로 RPC개념을 적용해야 한다.
프라우드넷 내부에 객체를 두고, 내부에서 WorkerThread와 AcceptThread를둔다.

우리가 패킷에 대한 메시지를 디자인하면, 메시지마다 자동으로 함수들이
만들어지고 switch-case문을 거쳐 함수코드까지 호출되는 부분까지 자동구현

-------------------------------------------------------------------------

우리가적용할 방식 vs 프라우드넷 IOCP구조

프라우드넷은 메시지마다 핸들러가 유동적으로 나와야하는데,
네트워크 본체 라이브러리에 들어갈 방법이 없으므로 난해해진다.

반대로 가상함수를 가지고 간단하게 핸들러 역할이 될 함수들을 
다 정해놓으면 간단하게 해결가능하다.

-------------------------------------------------------------------------

프라우드넷 IOCP 내부구조 순서

1. 내가 정의한 메시지에 따라 stub클래스의 가상함수가 만들어짐
2. 요소에 대한 내용들을 하나씩 상속받아 알맹이를 채운다.
3. 변경시킨 stub을 프라우드넷 클래스에 어태치(포인터 등록) 시킨다.
4. 함수를 호출시켜 포인터를 등록하면, 프라우드넷 멤버에 보관한다.
5. 메시지 처리가 완료되면 컨텐츠쪽으로 넘겨준다.

-------------------------------------------------------------------------

LAN-WAN함수이름은 프라우드넷 설계를 따온 것.
면접에서 물어볼수도 있음. 잘 설명해야할 것

-------------------------------------------------------------------------

LAN - WAN통신 용도분리

LAN : 서버-서버
WAN : 서버-일반클라

LAN-WAN통신을 한쪽으로 몰아놓고 코드상에서 메시지를 구분할수도 있음.
내부통신(LAN)인 경우 사설IP로 진행하기때문에 IP자체에서 막는게 훨씬간단.
(일반사용자 : 0.0.0.0, 서버통신은 내부용 172.16.n.n..)

-------------------------------------------------------------------------

LAN - WAN 패킷차이

WAN에서는 조작을 조금이라도 막고자 체크섬/암호화가 들어간다.
LAN은 신뢰할수있는 환경이라는 전제로 헤더만 넣고 들어간다.

-------------------------------------------------------------------------

LAN통신

대규모 접속처리 필요성이 없으며, 일반적으로 몇십개를 상회함.
정말 많은 경우도 600개정도
(대규모/소규모 접속처리에 대해 구현이 달라지는 점은 없음.)

- 최대한 간단한 프로토콜
- 간단한 사용법
- 보안 X

프라우드넷에서는 LAN클라 - LAN서버를 Reliable UDP로 구현해서 사용
(RUDP라고 해도 TCP의 기능들은 구현되어야함)

-------------------------------------------------------------------------

LAN-WAN환경을 분리하는 이유

기능상 구현은 아무문제없음.
단, 시스템메시지와 유저컨텐츠처리가 같이 들어가는 경우 문제가 생긴다.

-------------------------------------------------------------------------

시스템메시지 - 유저컨텐츠 처리 분리이유


1. 시스템메시지 우선

추가적으로 서버간의 통신은 중요도가 높으므로, 클라와의 통신량이 많다고하여
서버간의 통신이 떨어져서는 안됨. (유저수와 상관없이 보장되어야 함)


2. 보안상 문제

프로토콜이 공개되지않으므로 알아내기 힘들것이나 퇴직자가 접속하는 등의
예측하지못하는 예외상황이 있을 수 있음


3. 관리 용이

유저간 모듈 통신은 무거운편이므로, 서버간 통신은 개별적분리로 간단하게구현

따라서 IOCP핸들/스레드를 모두 분리시켜 메시지 프로시져 자체를 따로처리.
관리상에도 이점이 생긴다.



일반적으로도 서버간의 통신은 별도의 랜카드를 사용하여 다르게간다.

-------------------------------------------------------------------------

서버 설정은 서버라이브러리 밖에서 한다.

오픈IP / 포트 / 워커스레드 개수(생성,Running수) / Nagle옵션 / 최대접속자

-------------------------------------------------------------------------

서버 중지 후 재가동

가장먼저 ListenSocket을 닫아 유입을 막는다.
그다음 스레드들을 모두 파괴시키고 다시만들거나,
그대로 두고 다시돌게끔 만들 수 있을 것 (이 경우 굉장히 복잡)

하지만 서버를 stop할 일이 없으므로 구현은 하지않음.
서버를 끄고 다시키는 경우가 대부분
-------------------------------------------------------------------------

핸들링 함수

OnClientJoin() - Accept하여 접속처리 완료 후 호출
OnClientLeave() - Release가 끝나고 호출

목적 : 클라의 접속(할당)/끊김(해제)을 알림


OnSend() - Send완료 후 호출 
OnRecv() - Recv완료 후 호출 (메시지 들어옴)

목적 : 클라의 Send/Recv를 알림


OnWorkerThreadBegin() - 완료통지 직후 바로호출
OnWorkerThreadEnd()   - 워커스레드 로직처리 후 마지막에 호출

목적 : 워커스레드의 시작/끝을 알림. 디버깅, 스레드모니터링 등의 이유.


OnConnectionRequest() - Accept받자마자 세션세팅도 전에 호출 

OnError() - 네트워크 라이브러리 문제시 바깥으로 전달
가상함수로 둔 이유는 컨텐츠쪽에 분리된코드가 에러가 발생하는 경우를 알림
(클래스 내부 Try Catch는 본인이 알기때문에 가상함수X)

바인딩 에러, 직렬화버퍼 할당실패, 링버퍼문제, WSANOBUF 등

-------------------------------------------------------------------------

프라우드넷에서는 OnRecv/OnSend가 존재 X

프라우드넷은 인터페이스를 통해 바로 던져야하는 구조.
우리는 OnRecv라는 핸들러 하나로 커버.

OnRecv는 SessionID를 가지고 하나의 메시지당 한번씩 호출되는 구조

-------------------------------------------------------------------------

OnConnectionRequest()와 IP 블락

대규모로 간다면 대량으로 쏟아지는 접속차단은 방화벽에서 해야한다.
로그인 재접속 같은 경우 계정이 대상이므로 해당되지 않음


1. 내부에서 자동화시켜 뭔가를 일시적으로 해야할때.
(자동화 코드를 넣었을때 방화벽에 넣기전 일시적으로 차단대상을 차단)


2. IP밴을 하고싶은 경우
서버 패치 이후 컨텐츠 테스트를 할때, 허용된 일부IP만 허용하고싶은 경우

-------------------------------------------------------------------------

서버 오픈전 준비해야 할것들

운영툴, 관리를위한 로직, 패치제어, 화이트IP모듈 등 모든것들이 준비되어야함.

-------------------------------------------------------------------------

서버검증

1. 제일 원초적인 방법으로, 서버-클라를 동시에 만들면서 오류를 잡음
2. 테스트 클라를 최대한 심플한 환경(Select/block/싱글스레드)으로 테스트

IOCP서버를 몇달에 걸쳐서 만들기때문에 더미를 대충만들 수 없다.

-------------------------------------------------------------------------

멀티스레딩 환경에서 파일쓰기

CRL은 Thread-safe한 동기화 라이브러리이기 때문에, 모든 파일쓰기 함수는
내부에 CriticalSection이 내장되어있다.

실시간 파일저장은 굉장히 느리기 때문에, 메모리상에 올려놓고
일정량이 쌓이면 한번에 파일로 남기는 방법도 있다.


-------------------------------------------------------------------------

멀티스레딩 환경에서 로그

파일입출력은 안전하지만, 출력로그를 남기려면 락을 사용해야 한다.

-------------------------------------------------------------------------

멀티스레딩 디버깅

파일로 로그를 남기는 경우 IO작업으로 인해 Thread가 block된다.
심지어 Interlocked을 넣는 경우에도 발생하던 문제가 안나기도한다.

멀티스레드 환경에서 동기화 이슈를 추적하기 위함이라면,
굳이 문자열이 아닌 숫자로 추적을 해도 될것이다.

-------------------------------------------------------------------------

AcceptEx()

AcceptEx는 소켓재사용과 Accept()의 비동기 처리를 위한 두가지 용도로사용.

Accept() - closesocket()
AcceptEx() - transmitfile()

Accept()는 소켓생성이되고, closesocket시 소켓이 반환된다.
AcceptEx는 소켓의 리소스를 재활용하고,
transmitfile()은 소켓리소스는 그대로 두지만 연결정보만 삭제시켜 끊는다.



-------------------------------------------------------------------------

AcceptEx()의 성능

실제로 Accept의 성능향상이 존재한다.
동기화 락을 걸면서 깔끔하게 가는 구조인경우 상관없으나,
우리가 진행할 구조에서는 굉장히 복잡해지기 때문에 시도하지않는다.
(소켓닫은 입장에서도 굉장히 복잡해진다)

-------------------------------------------------------------------------

대기열 컨텐츠 구현

대기열의 기능은 컨텐츠에 가까우며, 연결이 됐지만 대기중인 상태라고 
클라쪽에서 알려줘야 한다.

따라서 동접자 이외의 대기열연결까지의 리소스를 생각해야 할 것.

따라서 네트워크 라이브러리 차원에서 구현하려면 대기상태/번호를 알려줄
핸들러(On...함수)가 나와야한다.


-------------------------------------------------------------------------

세션 배열 Index관리

세션을 배열로 사용한다면 자료구조 동기화가 필요없어짐.
단, 생성삽입시 Flag를 뒤져야 하므로 Index를 별도의 스택을 두고 관리한다.

-------------------------------------------------------------------------

SessionArray에서 FindSession 오버헤드

최악의 경우 배열 5천개를 모두 뒤져야 할 수있다.
따라서 SessionID자료형 내부에 영역을 분리하여 사용한다면 
바로 찾아낼 수 있다.

Index   /  SessionID
[2byte] /  [6byte]

동접자 65535까지 표현이 가능하므로 2byte를 차지시키고,
나머지는 SessionID영역으로 남겨둔다. (300조에 가까운 ID기록가능)      

상위에 넣을지 하위에넣을지는 알아서.

SessionID생성과 인덱스뽑기는 매크로함수로 사용하는것을 권장.

-------------------------------------------------------------------------

OnClientJoin - RecvPost의 순서

만약 Recv를 먼저 걸게된다면, 컨텐츠쪽에서는 접속의 유무도 모르는데
데이터가 추가된 것이다.

따라서 OnclinetJoin으로 접속자를 알려주고, 에이대한 처리가 완료되면
RecvPost로 송수신을 시작한다.        


-------------------------------------------------------------------------

RecvPost에서 Relase되는 문제

클라가 접속시도하여 연결됐는데, Accpet전에 끊어질 수 있다.
이 경우 Recv를 걸었을때 끊어지게 될것이다. 이상황을 고려해야한다.

(Send하다가 10054에러로 Release된다. 이 같은 예외처리까지 가지않도록 그전에 예외처리를 하자는것인가?)

-------------------------------------------------------------------------

더미테스트 재연결시

더미는 끊고나서 즉시 재연결을 할것이기 때문에, 서버에서는
미처 끊지 못했을 수잇다. 따라서 동접여유를 넣어줘야 한다.

일반적인 라이브서비스상황인 경우에는 이렇게 하지않음.

-------------------------------------------------------------------------

CPU사용률

1. CPU사용률 자체를 떨어뜨리는 것
2. CPU를 타이트하게 사용하여 사용률을 높이고 사용시간을 확보

두가지는 다른관점으로, 상황에 따라 다를것.

특정 함수를 호출시켰는데 CPU사용률이 높고 호출이 빠른것과,
CPU사용률은 낮지만 내가 바로 처리할 수 없는 경우는 느낌이 다름.

-------------------------------------------------------------------------

성능향상

오랜시간이 걸리는것을 줄이는것도 중요하지만,
매우 빈번하게 호출되는 것을 향상시키는것이 큰 성능향상이 있을 것

따라서 CMsg의 성능을 최대한 줄여본다

-------------------------------------------------------------------------

ZeroCopy

TCP스택 / 소켓 송신버퍼 / SendQ / CMsg

<-------------

CMsg의 주소를 링버퍼에 저장 (Copy -1)
링버퍼에 있는 CMsg포인터를 참조하여 데이터를 TCP스택으로 보냄 (Copy -1)

(송신버퍼를 0으로만들어 ZeroCopy를 유도한다)
페이지 락이걸리고 논페이지드 메모리를 더 많이 사용하게 될것이다.

-------------------------------------------------------------------------

CMsg* 해제

CMsg* 를 링버퍼에 보관했다가, Send시에 꺼내서 보내야한다.
이때 할당한 CMsg*메모리를 해제해야 하므로 주소가 기억되어야 한다.

1. Deque하여 보관하고, 완료통지왔을때 메모리 해제.
2. peek()을 통해 front를 변경해가며 뽑아서 해제.

Send보낼때 처음부터 준비한 세션내부 배열에 Deque하여 보관.
그리고 해당주소를 WSABUF에 넣고 Send한다면 가장 성능이 나을것.


-------------------------------------------------------------------------

하나의패킷을 전체유저에게 뿌리기(BroadCast개념)

패킷내부에 참조카운트가 존재하고, 해당카운트가 지워질때 0이되는
스마트포인터 형식이 되어야 한다.


어떤 SendQ에 들어갈때 참조카운트가 증가,
완료통지가 올때마다 참조카운트 차감,
최종적으로 0일때 메모리에서 해제된다.

-------------------------------------------------------------------------

스마트포인터 참조카운트 카운팅방식

스마트포인터는 만들어지는 순간 1이된다.
다른함수에 던져지면 참조 카운트는 증가하고,
해당 함수에서 모두 사용했다면 카운트는 차감된다.

-------------------------------------------------------------------------

스마트 포인터 방식으로 Session요소 동기화


Session의 경우 우리손에서 완전히 떠나는 경우가 생긴다.
이때 RefCount가 0이되므로 삭제되어 버린다.

스마트포인터 방식은 어딘가에서 물고있어야 하므로, 
세션요소 동기화로는 사용이 불가능.

-------------------------------------------------------------------------

직렬화버퍼 자체를 스마트포인터로 사용

CMsg* 를 카운팅할수있는 변수가 필요하므로,
CMsg를 감싸는 새로운 껍데기 클래스가 필요하다.

-------------------------------------------------------------------------

스마트포인터 방식의 오버헤드

스마트포인터가 생성될때마다 객체가 추가되므로 성능이 떨어진다.
(객체추가, 내부 포인터와 RefCount를 복사하는 형태)

-------------------------------------------------------------------------

스마트포인터 수동화 방식 사용

따라서 스마트포인터 방식이 아닌, RefCount를 수동 증감하도록 함.
왜 스마트포인터 방식이 아닌 수동인지 설명할 수 있어야 함.

-------------------------------------------------------------------------


스마트포인터 자동화 방식

CMsg*를 담은 껍데기 클래스를 사용하므로 CMsg는 어디에도 사용 X
(SendQ에 넣을때에도 CSmartMsg형태로 넣음)

이렇게 해야 복사생성자/대입연산자를 이용하여 자동화가 가능.

-------------------------------------------------------------------------

스마트포인터 자동화 방식 - Deque로직


Deque(CSmartPtr &pCnt)
{
	pCnt = _Data[front]; (대입연산자 호출)
	_Data[front++].~CpacketPtr(); (소멸자 호출하여 -1)
}

배열에 확보된걸 빼줬으므로 명시적으로 소멸자 호출.

실제 STL내부도 이렇게 돌아가게된다.

-------------------------------------------------------------------------

수동으로 하는 경우 장점


불필요한 복사행위(RefCount증가)를 줄임으로서,
객체의 생성과 객체의 생성자/소멸자 호출을 줄일 수있다.

수동/자동 둘다 CMsg 포인터타입 자체에 대한 Copy는 일어난다.
따라서 이는 수동화의 장점이 아님.

-------------------------------------------------------------------------

최적화 vs 성능

C++는 단독포인터가 아닌 스마트포인터를 권장하도록 가고있음.

생성/소멸자에 대한 오버헤드는 최적화를 키는경우 어느정도 해결된다.
(C++, 모던C++에서의 성능은 모두 최적화를 한다는 전제하에 언급)

최적화가 없다면 어마어마한 성능하락이 있다.

-------------------------------------------------------------------------

Release와 최적화

Release모드와 최적화모드는 다른 개념이며,
Release모드임에도 최적화 유무에 따라 문제가 생기는 경우도 발생한다.

이는 멀티스레드환경에서 순서가 뒤바뀌기 때문인데, 락을걸면 문제가 없다.
따라서 덤프가 남지않으면 굉장히 난감할것

-------------------------------------------------------------------------

최적화 사용시 디버깅

덤프가 남는다면 CallStack은 확인되나 이것조차 inline처리되었다면 파악X

이때는 단순히 어디쯤인가 파악하여 volatile을 심어야한다.

-------------------------------------------------------------------------

STL과 최적화

STL을 사용한다함은 최소한 Release모드로 가야하며, 최적화까지 권장.
Debug모드로 STL사용시 성능은 1/100까지 떨어질 것이다.

-------------------------------------------------------------------------

stateless에서 웹언어를 선택한 이유

모바일쪽에서는 stateless를 모두 웹으로 진행했었다. (Node.js, pho...)

stateless가 웹서버를 선택한 이유는 개발이 편하고 웹개발자가 싸기때문.
대신 천배이상의 성능저하를 안고간다.

-------------------------------------------------------------------------

stateless에서 웹언어를 버리는 추세인이유

C++개발자 입장에서는 성능하락이 매우 심하므로 C++로 stateless가
개발되기 시작했다. (stateless개념이 필요한것이지, 웹서버가 필요한것 X)

지금은 거의 공식적으로 stateless에서 웹을 버리자고 발표된 상황이다.

일단은 웹언어를 버리는 추세이지만, 더나아간다면 http까지 버릴것.
이는 CPP로 http를 통신하는 서버를 만들겠다는 의미.

-------------------------------------------------------------------------

게임서버가 난해한 이유

stateful개념이 적용된 C++게임서버는 데이터공유, 스레드간 동기화 이슈등
으로 인해 어려운것으로, stateless인 경우 클라가 스레드를 하나씩 가져가므로
어려울게 없다.


-------------------------------------------------------------------------

직렬화버퍼 주소Copy시 단점

로컬로 쓰고 버렸으나 이제는 보관해야하므로 동적할당이 필요함.
따라서 new/delete에 대한 오버헤드가 생김.

따라서 컨텐츠쪽에서 메모리풀로만 직렬화버퍼 할당이 가능하게끔 한다.

-------------------------------------------------------------------------

직렬화버퍼의 계층간 전달

엄격하게 계층을 나눈다면 컨텐츠쪽에서는 복사해서 넘기면 끝이고,
내부에서 알아서 동적할당하여 처리하는것이 맞다.

하지만 이경우 Copy가 한번 더 추가되는것이기 때문에
직렬화버퍼에 관리자로 보는관점으로 넘어가자.


-------------------------------------------------------------------------

잘못된 SessionID로 요청

SendPacket, DisconnectSession에 대해 잘못된ID로 요청하는경우,
이는 컨텐츠 쪽의 실수이므로 서버쪽에서는 단순히 return false하는걸로 끝남.

-------------------------------------------------------------------------

현재구조 상 문제

OnClientJoin() 이후 RecvPost()를 들어간다.
누군지도 모르는 클라에게 데이터가 왔다는것은 말이 안됨

이때 OnClientJoin부분에서 SendPacket을 호출하면
IOCount가 0인상태에서 본인혼자 1로올렸다가 0으로 떨어뜨려 Release.

일단 클라가 연결됐다면 서버가 먼저 송신을 하는게 맞음
따라서 서버가 송신한것을 클라가 받고 최종연결을 결정

이후 클라에서 보내는 데이터를 확인하여 처리

-------------------------------------------------------------------------

OnClientJoin()이전에 IOCount증가.

Recv걸기전에 연결확인패킷에 대한 완료통지가 먼저 와버리면
이때 Release타버릴 수 있음.

-------------------------------------------------------------------------

메모리풀 예외처리

메모리풀에서 동적할당한 메모리를 제공할때, 잘못된 블록을 free하면?

만약 사용자가 free를 던지는 경우는 Critical한 에러이므로
이를 허용해서는 안된다.

-------------------------------------------------------------------------

메모리 직렬화버퍼의 문제

메모리풀의 우선순위는 무조건 속도.
따라서 직렬화버퍼는 placement new로 생성자를 호출시키지않고,
단순히 Clear()를 사용해 버퍼를 비워준다.

(메모리풀 만들때 최초 1번호출 / 생성할때마다 호출 설정이 가능하게끔 만듬)


-------------------------------------------------------------------------

메모리풀 직렬화버퍼

직렬화버퍼 내부에 메모리풀을 가짐.
사용자 실수를 막기위해 생성자를 막음.

Alloc/Free()로 생성/해제 함수를 만들고, 생성자가 없으므로
static으로 만들어 호출할 수 있게끔 함

-------------------------------------------------------------------------

직렬화버퍼 참조 카운트 개념 도입

이름이 직관적으로 떨어지지않으나, 성능우선으로 한번 짜볼 것.

-------------------------------------------------------------------------

직렬화버퍼 할당 개수

평소에는 열댓개가 유지되나, 서버의 부담이 심해지면 백만개 이상초과.
(완료통지가 왔을때 직렬화버퍼를 해제하기 때문이다.)

이를 가비지컬렉터를 이용해 다시 지운다고 하더라도, 언제 또 백만개로
치고 올라갈지 예측되지않음.

-------------------------------------------------------------------------

멀티스레딩 환경에서 싱글톤

최초 요청시 동적할당하는 형태의 싱글톤은 멀티스레딩 환경에서 구현불가.

if(nullptr = p)구문에 동시에 들어가는 경우, 두개가 만들어질수있음.

변수를 하나두고 인터락으로 판단한다면, 한쪽이 생성중일떄 한쪽이 null리턴

p가 nullptr인지 InterlockedCompareExchange한다면 나중에 들어온애는
그냥 구문을 거치지못하고 나가버릴것

-------------------------------------------------------------------------

call_once():

c++11에서 멀티스레드 환경에서 싱글톤을 안전하게 사용하기 위해 만듬.
call_once는 Mutex헤더를 include해야 사용이 가능하고,
내부에서 SRWLock을 걸지만 재귀락을 커버하기위해 CriticalSection으로 랩핑.

결국 call_once는 동기화객체를 쓰는것과 같다.

싱글톤 객체를 호출할때마다 인터락함수 체크코드가 들어가고, 이는 
다른방법에 비해 성능저하를 가져옴.

-------------------------------------------------------------------------

Alloc()호출시마다 Interlocked체크?

엄청난 성능하락을 야기할것

-------------------------------------------------------------------------

메모리풀의 내부크기 증가


하나씩 증가시켜도 되지만, 많이 잡아놓아도 상관없다.

vector가 Capacity를 크게 증가시키는 이유는 하나가 삭제될때마다
기존것들을 옮겨야 하는 문제가 존재하기 때문,

-------------------------------------------------------------------------

싱글톤 결론

CallOnce를 선호하지 않는 개발자의 경우 동기화객체 동적생성을 좋게보지않음.

따라서 실제 싱글톤으로 만들지만 내부 객체를 static으로 명시하거나
바깥에서 명시적으로 호출한다음(초기화) 돌아가게끔 구현.

-------------------------------------------------------------------------

서버 - 클라간 메모리 사용

서버입장에서는 어차피 사용하는경우 비용을 치르고(메모리를 잡아두고)
가는게 좋지만, 클라의 경우는 필요할 때 쓰고 필요없으면 지우게끔 간다.

-------------------------------------------------------------------------

가비지 컬렉터

윈도우내부에서도 가비지컬렉터 스레드가 계속 돌고있다.
물리메모리에 상주해있는 것들 중 Page-Out이 될만한 것들을 판단하여 Out한다.

또한 스레드 우선순위 역전 문제를 해결하기위해 별도의 스레드가 계속 확인.

-------------------------------------------------------------------------

스레드 우선순위 역전

우선순위 Task1 -> Task2 -> Task3 라고 가정한다.

1. Task3이 공유자원 접근위해 동기화객체 획득
2. 스케쥴러에 의해 Task1 수행
3. Task1는 Task3의 동기화 객체가 필요해서 기다림(block)
4. 스케쥴러에 의해 Task3실행
5. 이때 관련없는 Task2가 Task3을 밀어내고 실행
6. 결국 우선순위 가장높은 Task1이 가장 늦게 실행

-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------
