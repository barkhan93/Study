덤프 파일

서버는 항시 문제가 터지게 되므로 실제 라이브 서비스에서도 덤프파일이 많음.
해결하면 지우는 식이다.

------------------------------------------------------------------------

덤프파일 빼기

서버쪽에서는 풀덤프로 프로세스의 모든 메모리 저장.
서버가 2GB인경우 덤프도 2GB (파일이 크지만 저장만 할것이므로 문제 X)

클라쪽은 풀덤프 파일크기가 부담되므로, 스택메모리와 스택상태만 저장.
(몇KB정도로 작게나오지만, 전역메모리 등을 확인할수 없음 -> 디버깅 힘듬)

------------------------------------------------------------------------

덤프 제공

덤프파일은 WINAPI에서 제공 사용한 DLL을 확인할수 있으며 
플레이버튼을 눌러 디버깅창을 띄워 디버깅 가능

------------------------------------------------------------------------

멀티스레드 환경 디버깅


오면 안되는 상황을 캐치하여 덤프로 저장하고, 이를기준으로 디버깅

단, 락프리의 경우 덤프를 저장하려는 순간에도 다른스레드는 멈추지않아서
저장된 데이터가 새로 바뀌는 등의 상황이 일어남

따라서 멀티스레드 환경에서는 덤프만을 100%믿을 수 없고,
이에 대한 해결책은 직접 찾아야함.

------------------------------------------------------------------------

덤프를 남기기위한 조건

1. 덤프를 남길때 실행된 exe실행파일
2. 해당 실행파일을 빌드할 때 있던 pdb파일

------------------------------------------------------------------------

pdb파일 (반드시 보존)

우리쪽 소스코드와 기계어를 맵핑시키는 역할

exe파일만 가지고서는 브레이크 포인터디버깅이 불가능하고,
[프로세스 연결]로 메모리/어셈블리 확인만이 가능하다.

------------------------------------------------------------------------

exe파일과 pdb파일

pdb에는 빌드할때마다 타임값으로 소스코드 버전관리된다.
해당 실행 파일을 만들 때 생성된 pdb파일만이 맵핑 가능하고,
새로 빌드한다면 기존pdb파일과 맵핑되지않는다.

따라서 exe파일과 pdb파일은 세트로 보관해야 한다.

------------------------------------------------------------------------

pdb파일이 없거나 버전 다른경우

VS에서는 버전에 맞는 pdb파일을 찾을수 없다고 에러가난다.
차선책으로 WinDebug같은 프로그램을 사용하여 강제로 pdb올려 셋팅한다.

이는 메모리 위치를 맞추는 등 복잡한 작업을 요하고,
VS에 비해 보기도 어렵다. 
따라서 반드시 같이남는 pdb파일을 보존시켜야 한다.

------------------------------------------------------------------------

Dump남기는 코드

WINAPI에 있는 MiniDumpWriteDump를 호출시켜 진행.
Dump코드는 사실상 모두 똑같으므로 이해하여 그대로 사용.

------------------------------------------------------------------------

덤프가 남지않는 경우

UnhandledExceptionFilter(핸들링되지않은 모든예외를 캐치)를 호출해도
100%보장되지않으며, 남지않은 경우 별다른 방법이 없음.

1. 우리쪽으로 핸들링 되지않은 경우
2. 핸들링 되었는데 덤프를 남기는 과정에서 실패
(용량이 0이거나, 깨진상태이거나, 아예 남지않는 등 다양한 이유)


우리가 임의로 NULL포인터를 찔러 메모리참조 오류를 내는것은 거의 100%보장

------------------------------------------------------------------------

덤프가 남지않는 경우 - 1. 우리쪽으로 핸들링되지않음

윈도우 2013까지는 CRL내부에서 시큐리티쿠키(오버플로, 언더플로 체크) 내장.

시큐리티쿠키 내부에서 예외가 발생하여 SetUnhandleExceptionFilter를 호출
시키는 경우 런타임 라이브러리 내부로 핸들링이 전환된다.

이상황에서는 덤프를 뺄수없음.

------------------------------------------------------------------------

WINAPI 후킹

위와같은 상황을 우회하는 방법으로 SetUnhandle..() API자체를 후킹하는방법.
후킹이란 함수호출, 메시지, 이벤트 등을 중간에 바꾸거나 가로채는 방법.

이 방법은 내 프로세스 메모리에 함수테이블을 모두 조회하여, DLL커널 내부에
존재하는 Setunhandle..()에 맵핑된 함수 포인터 주소를 내함수로 바꿔치기함.

굉장히 복잡하고 API관점에서 좋지않은 행위이므로 window8부터 작동안됨.

via에서도 소스코드를 제공하고 참조하라는 정도로만 넘어간다.

------------------------------------------------------------------------

덤프가 남지않는 경우 - 2. 핸들링 되었으나 덤프를 남기는 과정에서 실패


Heap을 따로 만드는 이유와도 일맥상통한다.
단순히 동적할당 메모리에 대한 오버플로우는 해제할때 예외 발생,
힙을 심각하게 깨뜨린 경우 Heapalloc에서 에러.

이때 MyExcptionfilter가 호출되지만, 내부 CreateFile은 힙메모리를 사용
하므로 호출이 실패되어 덤프를 남기지 못하게 된다.

------------------------------------------------------------------------

외부에서 덤프 남기기

내부에서 위와같은 이유로 덤프남기기가 실패했다면, 외부에서 덤프를 남김.
외부덤프를 빼는 프로그램을 사용. 
(윈도우 XP까지는 닥터왓슨제공했으나, 64비트 용이 나오지않음)

현재 VS를 설치한 환경에서는 JustInTimeDebug를 사용하도록 세팅하여,
VisualStudio로 디버그하게끔 한다.


우리는 외부에서 덤프를 뺄 방도를 찾고있으므로
MS의 WindowSysInternel에서 제공하는 프로세스 덤프라는 프로그램을 사용.

------------------------------------------------------------------------

우리쪽으로 핸들링하는 예외들

1. pure virtual function called

	자식클래스가 부모클래스의 순수가상함수를 정의하지않으면 컴파일에러
	단, 포인터로 정의하여 접근하는 경우 알수 없으므로 문법이 허용,
	pure virtual function called에러 발생.


2. C++라이브러리 예외 핸들러

	파라미터 에러 외 4개 (코드참조)

------------------------------------------------------------------------

덤프클래스 내부 함수가 static인 이유

이는 어떤곳에서든 서버를 즉시 종료하고 덤프를 남겨야 하는 상황에,
Crash()를 호출하기 위함이다.

static을 선언하면 소속이 생기므로 다른파일에서 같은 이름이 있어도 구분.

우리가 만드는 함수들은 함수 포인터로 내부에서 등록이 되므로,
일반 클래스 멤버가 아닌 static으로 가야한다.

------------------------------------------------------------------------

MyExceptionFilter()

덤프클래스 안쪽에서 MyExceptionFileter()함수 내부는 디버깅 되지않는다.
VS가 디버거가 됐기 때문에, UnhandledException필터를 VS가 하게된다.
따라서 안쪽에 브레이크를 걸 수 없음

------------------------------------------------------------------------

프로세스의 메모리사용량을 얻는 방법

현재 프로세스에 대한 메모리를 판단해 덤프 파일이름에 남기기.
덤프파일의 용량이 곧 메모리 크기이므로 없어도 상관없음.

------------------------------------------------------------------------

게임서버 DB저장

데이터 DB저장은 행동 할때마다 비동기 처리되는 별도 스레드에 큐잉.
로그는 별도의 로그DB에 저장한다.

------------------------------------------------------------------------

stateful서버의 데이터 저장

stateful에서의 데이터 저장은 1차적으로 메모리 변화가 있고 그다음 DB저장.
따라서 롤백개념(DB저장에 실패해서 그전 데이터로 돌아가는 현상)이 존재

이때 로그와 DB반영 둘다 반드시 남아야 한다. (하나만남는건 X)

------------------------------------------------------------------------

트랜잭션

commit/롤백 중 하나는 반드시 보장되게끔 한다.

1. 게임내에서 레벨이 오름
2. 오른레벨 컨텐츠 로직에 반영
3. 유저 레벨업을 DB저장

위 셋 목록을 같은 DB에 넣고 트랜잭션으로 묶어서 해결하는 방식.

------------------------------------------------------------------------

트랜잭션 사용 시

성능이 약간 떨어지게 됨
서버마다 로그가 나오게되고, 이는 관리면에서 매우 불편함
(게임로그는 DB로 저장함)

유실걱정없이 완벽하게 처리가능

------------------------------------------------------------------------

트랜잭션 미사용 시

DB저장/로그 중 하나가 유실될 수 있음

하지만 유실되는 상황은 하드웨어적인 문제이며 m/s단위보다 작은 찰나의 순간
이므로, 가능성이 거의 없다고 봄.

트랜잭션을 하지않고 진행할 시 유실된것에 대한 해결방안을 고민
(로그먼저? 컨텐츠 반영먼저?)

------------------------------------------------------------------------

트랜잭션 직접 구현

트랜잭션도 DB라는 시스템도 C로 구현되어있기 때문에 직접구현가능
소프트웨어 트랜잭션을 직접 구현하는 케이스도 존재.

하지만 이는 차후의 방법으로, 처음부터 직접구현하는것은 비권장

------------------------------------------------------------------------

게임로그

게임로그는 클래스화/라이브러리화 시키지 않는다.
컨텐츠와 밀접하게 들어가는 부분이므로 컨텐츠를 만들때 들어간다.

게임로그로 해당 유저가 게임내에서 어떤 행위를 했는지 CCTV를 설치한것처럼
모든것을 알 수 있어야 한다.
(단순한 좌표이동은 기록X, 마을과 마을정도의 큰이동이라면 기록)

------------------------------------------------------------------------

서버개발자가 기록해야할 게임로그


게임로그를 볼수있게끔 웹프로그램으로 만드는 작업은 웹개발자가 할일.
서버프로그래머의 역할은 깔끔하게 저장.

게임로그는 서버를 느리게하지만 반드시 남겨야하는 데이터이므로 감안.
다른서버 연동, DB연동 등이 들어가면 게임서버는 당연히 느려진다.

서버를 아무리 잘 만들어도 DB가 받쳐주지 못하면 (스케일 업을 했음에도)
 동접을 떨어뜨려야한다.)

------------------------------------------------------------------------

게임서버가 버그가 난 경우

1. 코드확인  ->  2. 텍스트로그 확인  ->  3. 게임로그 확인

로그를 확인하여 해당 유저의 행위를 똑같이 따라한다.

재현되지않으면, 라이브서비스의 DB를 백업받아 해당 유저로 로그인하여
완벽하게 똑같이 따라한다.

------------------------------------------------------------------------

게임로그 특징

DB쿼리와 로그쿼리는 무조건 저장
게임로그는 무조건 DB에 저장됨

게임데이터가 저장, 변경되는 순간 저장한다.
(트랜잭션 여부와 순서는 선택의 영역)

------------------------------------------------------------------------

게임 로그저장

게임로그는 DB에 저장되는 시점에 함께 저장된다.

[ Server / Type / Code / AccountNo / Param1 / Param2 / ParamStr... ]

모든 컬럼은 숫자 타입을 사용하는게 좋음.
숫자표현이 안되는 경우 마지막컬럼을 스트링으로 사용.

------------------------------------------------------------------------

로그저장 포맷

로그는 최대한 구체적이고 직관적으로 기록되어야 한다.

[ Code : 돈획득 / Param : 10 Gold ] (X)
[ Code : 몬스터 잡아서 돈 획득 / Param1 : 잡은 몬스터 / Param2 : 10 Gold /
Param3 : 총 1000원 보유 ] (O)

------------------------------------------------------------------------

게임로그 분산저장

게임로그는 하루에 TB로 남을때도 있을 정도로 용량이 크다.
따라서 분산하여 저장하고 관리해야 한다.


이때 게임로그는 컨텐츠별로 나누지않고 기간별로 나눈다.
DB테이블을 기간별로 분류하고 테이블안에는 모든 게임로그 저장.

게임로그는 유저의 행동을 추적하기 위함이기때문.

------------------------------------------------------------------------

그밖에 로그가 필요한 경우

DB변화가 없음에도 기획팀 / 사업팀에서 필요로 하는 경우 넣어줘야한다.
어떤 버튼을 몇번누르는지, 특정시점에 유저들의 행동패턴, 특정지역에 몇명 등

위 사항중 몇가지는 클라족에서 코드를 심어 외부로 빼는것도 가능하다.

------------------------------------------------------------------------

시스템 로그 (파일에 저장하는 로그)

시스템로그는 개발자를 위한 로그로, 개발 중 모니터링 항목에는 없고,
잠깐 주기적으로 보고싶은 경우 넣는 로그.

(ex 메모리풀을 모니터링 시, 추가로 NPC객체에 대한 메모리사용량 확인)

------------------------------------------------------------------------

시스템 로그 특징

- 로그분류 / 날짜, 시간 / 문자열
- 파일저장시 - 분류별로 월별 저장
- DEBUG / WARNING / ERROR / SYSTEM(NOTICE:주의) 등 4단계로 저장.
- 코드 설정을 통해 콘솔/파일. (공부시 둘다권장)

메인함수 시작시 로그폴더부터 설정하고 로그레벨을 지정하도록 함

시스템로그는 컨텐츠별 분류 가능.

------------------------------------------------------------------------

모니터링 서버

회사차원에서 관리되며, 수집하는 모든 데이터(CPU메모리 사용률, 동시접속자)
를 로그로 누적하여 남긴다.

별도의 서버를 빼는 형태로 새로운 항목을 넣고자한다면 DB저장, 네트워크연동
프로토콜 추가 등 복잡한 과정이 필요하다.

------------------------------------------------------------------------

시스템 로그 성능이슈

시스템로그가 많이 남을수록 당연히 성능은 떨어진다.
하지만 시스템로그는 비정상적인 상황에서 남기에, 성능이슈는 신경 X

------------------------------------------------------------------------

시스템로그 파일저장

파일이름 : 년월 + 타입.txt 

ex) 201509_Battle.txt
월단위 저장 권장.

파일내용

[Battle] [2015-09-11 19:00:00 / DEBUG / 000000001] 로그문자열.........
[Battle] [2015-09-11 19:00:01 / WARNG / 000000002] 로그문자열.........
[Battle] [2015-09-11 19:00:01 / ERROR / 000000003] 로그문자열.........

추가로, 로그카운터를 심으면 멀티스레드 환경에서 순서를 명확하게 할수있음

------------------------------------------------------------------------

중간정리 - 로그별 분류

게임로그 - DB저장 - 시간별 분류
시스템로그 - FILE저장 - 컨텐츠 분류(파일은 월단위)

DB는 검색이 용이하므로 하나의 테이블에 몰아서 저장
FILE은 검색이 어려우므로 종류별로 분류.


------------------------------------------------------------------------

시스템 로그파일 Open/Close

비효율적이게 매번 open/write/close를 해야한다.

1. 서버가 운영되는 상황에서 로그파일을 열고 확인이 가능
2. 경우에 따라 로그파일을 서비스중 삭제해야 하는 경우 있음
(반복 로류로 인하여 용량이 커지는 경우 : GB단위면 확인 어려움)

------------------------------------------------------------------------

멀티스레딩 환경에서 파일저장 실패


1. 같은 타입의 로그를 두곳이상에서 남기려고 하는 경우

동기화 객체사용시 타입 종류별로 동기화객체를 나눠야함.
(병렬로 돌수있는 로그들이 돌지 못하는 상황을 막기위함)

성능에 영향을 줄 정도로 로그를 쏟아낸다면 문제가 이미 심각하므로,
이를 고려하지 않고 간다.


2. 동시접근이 아닌데 파일오픈이 실패하는 경우

백신프로그램에서 파일의 변화감지시 들어가 확인하는 작업을 함.
굉장히 짧은 순간이지만 빈번하게 파일 읽기/쓰기되므로 실패할 확률있음.

로그 기록은 굉장히 중요하므로 실패시 일정회수 재시도 이후 서버를 꺼야함.
(개인적인 생각. 물론 신입때는 결정X)

이렇게 재시도하는 코드를 넣은 경우 파일중복오픈이 불가능하기때문에
동기화객체를 넣지않아도 돌아가게 될 것.


------------------------------------------------------------------------

시스템로그 코드

void Log(WCHAR* szType, LOG_LEVEL LogLevel, WCHAR* szStringFormat, ...)
{
	WCHAR szInMessage[256];

	va_list va;
	va_start(va, szStringFormat);
	HRESULT hResult = StringCchVPrintf(szInMessage, 256, szStringFormat, va);

	va_end(va);
}

시스템로그레벨은 런타임에서 판단하며, 서비스 도중에도 변경이 가능하다.
설정레벨 이상은 모두 로그로 남기는것으로 한다.

------------------------------------------------------------------------

시스템 로그 안전성

시스템로그는 최후의 장치이므로, 로그자체에 문제가 생기면 안된다.
(strsafe.h를 사용하는 이유)

만약 버퍼를 초과하여 데이터가 절사되면, 이 조차도 로그로 남겨야함
로그오류에 대한 로그를 남긴다면 재귀적으로 들어갈 수 있는 위험 존재
이 경우도 대비하여 알아볼수있게 로그로 남겨야 한다.

------------------------------------------------------------------------

LogHex

void LogHex(WCHAR *szType, LOG_LEVEL LogLevel, WCHAR *szLog, BYTE *pByte, int iByteLen);

바이너리값 자체가 확인이 필요한 경우 사용
(메시지 수신버퍼 내용확인, 원인미상 객체 메모리 자체 로깅 등)

------------------------------------------------------------------------

LogHex 사용처

Recv했는데 마샬링 되지않는 경우 해당 클라는 끊도록 했다.
단순히 끊는것 뿐 아니라 무엇을 보냈는지, 
이러한 데이터가 빈번하게 온다면 해당IP또는 유저를 밴해야 한다.

간혹 클라쪽 버그인 경우가 있는데, 이때 16진수로 모두 찍어(LogHex)
무엇을 보냈는지 메모리를 하나하나 확인 해 볼수 있다.

이 밖에도 수신버퍼/객체메모리 자체를 저장해야하는 경우 유용하게 쓰임.

------------------------------------------------------------------------

시스템 로그 콘솔출력

파일에 저장되는 내용 그대로를 화면에 printf로 출력한다.
간혹 문자열이 너무 길어지는 경우 일부 항목 제외

------------------------------------------------------------------------

시스템 로그 보존

시스템 로그역시 모두 백업하여 보존시켜야 할 데이터이다.
새로운 컨텐츠가 추가되며 조금씩 변하는 수치에 무뎌지기때문.

따라서 이전로그를 보고 년단위로 비교하는 경우도 있음.
소스코드 역시 모두 버전관리 된다.

------------------------------------------------------------------------

그외 서버개발자 업무

프로토콜 설명 등 구체적인 내용을 모두 문서화하여 남긴다.
실제 현업에서는 코딩외에도 문서 작업이 굉장히 많을 것이다.

------------------------------------------------------------------------

시스템로그 구체적인 사용처


1. 국가별로 서비스 시, IP 블락

국가별 IP를 제공하는 웹사이트 이용(정확도 98%)
방화벽 같은 경우도 국가차단이 내장되어있지만, 결국 해당DB를 활용한다.
기기별로 갱신하면서 csv별로 모두 공개한다.

차단할때마다 IP와 계정이 나오는데, 문의확인하여 가끔 잘못판단된 경우 확인


2. 응답이 없는 경우 로그

특정시간 전혀 수신되지않으면 끊고, 시스템로그를 남긴다.
보통 동접 3~4만 정도일때 열댓개 정도 남음 (생각보다 많음)
원인 미상으로 급격하게 수치가 늘어난다면 추적해서 파약.


3. 체크섬 오류

위변조 패킷인 경우도 있지만, 패치이후 클라쪽 패치가 되지않아 오류가 잡힘.
이 경우 문의가 왔을 때 클라가 재설치하라는 안내라도 해야하기 때문에 파악.


4. 프레임 딜레이

1초에 얼만큼의 루프를 도는지 파악.
메인 업데이트 로직에서 루프돌때마다 일정시간이 걸리는 경우 로그심음
(매번X)

ex) 100프레임(초당 10m/s)인데 200m/s이 넘는경우 로그
오류가 잡히면 서서히 기준치를 낮춘다.


5. 중복로그인

같은 계정으로 두번의 로그인이 들어온다면, 로그조차 남기지않고
중복되는 계정을 끊는다면 이는 전혀 파악되지않음.

------------------------------------------------------------------------

로그남길때 주의해야할 사항들

전사람이 남긴걸 모르고 새로만들거나, 이전로그가 구체적이지않아 새로
만드는 등 중복되는 로그가 많이 생길 것.

오래된 게임같은 경우 정상수치가 핵으로 판단하는 수치까지 따라와서
일반유저를 핵으로 판단해버릴 수있는 경우도 생김.

운영자에게는 여러 권한이 있고, 해킹당하거나 비리를 막기위해 
운영자 행동은 모두 DB차원에서 로그를 남긴다.


------------------------------------------------------------------------

원인 미상의 에러 상황

게임로그서치, 시스템로그 서치 및 변경, IDC센터에 문의 등
얻어낼수있는 모든 정보를 취합하여 원인을 파악해야 한다.

서버작업은 이런작업들의 일상이다.

------------------------------------------------------------------------

다른서버(MySQL, 아파치 등)

MySQL이나 아파치도 기본은 파일이고, 가동/로딩될때 해당 프로세스 옆에
모든 로그를 남긴다.

서버가 수십대일 경우 서버마다 로그파일이 생기기때문에 관리가 힘들다.
이를 일괄관리하고자 한다면 주기적으로 스케쥴러를 통해 수집하는 솔루션,
배치파일 등을 이용해 코딩하는 등의 준비작업 필요.

------------------------------------------------------------------------

DB저장과 파일저장

DB에 쏘는것은 유실될 가능성이 있으므로 파일에 남길수있다면 파일에 남김.
대신 파일은 관리가 힘들다.

파일을 선호하는 경우 아침마다 터미널에서 서버와 로그를 확인하게 될 것.
이 방식이 귀찮다면 별도 네트워크로 연결된 서버나 특정폴더에 자동카피.

------------------------------------------------------------------------


------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------
------------------------------------------------------------------------

















