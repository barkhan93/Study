-----------------------------------------------------------------------------------------------


Client / Server 방식

클라는 사용자의 입력, 결과 그래픽처리, 애니메이션, 이펙트등의 게임뷰어 역할을 한다.
서버는 캐릭터 이동경로, 몬스터AI, 데미지, 보상등 게임 대부분의 컨텐츠 로직을 처리한다.

-----------------------------------------------------------------------------------------------

C/S방식의 장점 

서버 단독 처리로 일관성있는 결과처리, 동기화 편리.
악의적인 데이터 수정이나 핵 사용이 불가능.
대규모 플레이어의 상호작용 가능.

-----------------------------------------------------------------------------------------------

C/S방식의 단점

게임서버 로직부담이 큼.
개발기술이 높고, 유지비용 많이듬.
모든 로직이 서버를 경유하므로 응답성이 다소 떨어짐.
서버의 부하나 통신지연으 이유로 액션의 정교한 처리가 다소 어려움.

-----------------------------------------------------------------------------------------------

액션성이 강한 게임

클라-서버의 단점때문에 액션성이 강하거나 유닛컨트롤을 요하는 전략 시뮬레이션 게임에서는
클라-서버 구조를 사용하지않았다.

또한, 서버에서 정교한 충돌처리가 어렵기때문에 논타겟팅 게임이 많지 않다.
(예외로 테라가있음)

최근에는 서버기술 및 네트워크환경의 개선으로 대부분의 게임이 클라-서버로 가게된다.

-----------------------------------------------------------------------------------------------


Peer to Peer 방식


흔히 P2P방식이라고 한다.  대부분 10명내외의 적은게임으로 게임을 진행하는 MO류의 게임에서
주로 사용되곤 한다.
플레이어 클라에서 직접로직을 처리하므로 서버의 부담이 적고 빠른 액션처리와 정확한 충돌처리가능.
따라서 FPS슈팅게임이나 액션게임, 스포츠 게임들이 P2P방식을 많이 사용했다.

P2P방식은 다시 2가지로 나뉜다.

-----------------------------------------------------------------------------------------------


P2P - 일반적인 P2P


게임에 참여한 플레이어가 그물처럼 모두 연결된다.
자신의 컨트롤이나 처리결과를 다른 플레이어에게 직접 알려주는 방식이다.

장점
직접 메시지를 상대방에 전달하므로 네트워크 지연 최소화
나의 로직을 내가 직접 처리하므로 정교하고 빠른 처리 가능 (서버부담없음)

단점
클라데이터가 조작되면 검증불가
로직이 분산되므로 판정에 어려움이 있음. 동기화어려움.
(하나의 아이템을 동시에 두명이 먹었다면 누가 먹은것으로 해야하는가?)

-----------------------------------------------------------------------------------------------

P2P - 호스트방식

플레이어중 특정 1명이 호스트(서버)역할을 하여 다른플레이어들이 호스트에 접속한다.
이는 실제로는 클라서버와 같은 구조이지만 서버역할을 호스트(클라)가 하는것.

장단점은 기본 P2P와 비슷하지만, P2P의 동기화문제를 해결할 수있다.
(단 응답성은 P2P보다는 약간 떨어질수있음. 경유지가 생겼기 때문)

-----------------------------------------------------------------------------------------------

P2P방식이 점점 사라지는 이유

빠른 응답성등의 장점을 가지고있지만 결국 핵을 막을수있는 방법이 없다.
핵은 게임사에게 치명적인 피해를 주기떄문에, 결국은 클라-서버 구조로 간다.

-----------------------------------------------------------------------------------------------

타겟팅

타겟팅은 플레이어가 컨트롤러로 공격대상을 지정하는 방식
서버-클라간 좌표 동기화 문제가 없으므로 구현하기 간단하다.
서버부하를 줄일 수 있으므로 대부분이 타겟팅 방식
액션성이 떨어질 수 있음

-----------------------------------------------------------------------------------------------

논타겟팅

논타겟팅은 실시간으로 공격대상을 판단하는 것
실시간으로 공격범위에서 오브젝트를 찾아야한다.
간단한 2D MMO의 경우 서버측 부하가 크지않지만, 3D게임은 서버의 충돌계산 로직에
부하가 상당하다.

최근에는 논타겟팅이 흔해졌지만, 오토타겟팅 방식도 많이 개발된다.


-----------------------------------------------------------------------------------------------

서버에서 공격수행

1. 클라가 공격대상 지정(타겟팅)
2. 몬스터 (고유번호)를 기술(공격이름)으로 공격 메시지 서버로 전송
3. 클라 메시지 검증 (거리, 장애물, 해당스킬 사용여부 등)
4. 공격이 가능하다면 데미지를 계산 적용하여 결과 클라를 전송
5. 클라) 서버로부터 받은 공격결과에 따라 공격 액션 및 이펙트 표시

이때 가장많은 연산을 하게되는것은 "공격으로 맞은 피해자 찾아내기"
그리고 실질적인 충돌처리.
3D MMO게임이라면 확인해야할 오브젝트도 많고 폴리곤 충돌 계산량이 많다.

-----------------------------------------------------------------------------------------------


논타겟팅의 장점

유저가 전투 액션성/조작감 재미를 느낄 수 있음

-----------------------------------------------------------------------------------------------

논타겟팅 단점

서버가 다수의 몬스터를 대상으로 충돌 판단을 해야하므로 서버부하가 크다.
서버와 클라이언트간의 동기화가 맞지 않는다면 판정에 불만이 생길 수 있음.
(내 화면에서는 분명히 안맞았는데 동기화문제로 내가 죽을 수있음)

오브젝트가 많은 MMO의 경우 원하는 타겟에 대한 공격이 어려움

-----------------------------------------------------------------------------------------------

오토타겟팅 (ex 블레이드 앤 소울)

오토타겟팅은 '논타겟팅'같은 '타겟팅' 게임.
유저가 직접 마우스나 탭으로 타겟을 선택해야 했던 타겟팅 방식에서 플레이어 캐릭터의
시야 전방에 위치한 몬스터에게 자동으로 타겟팅이 되는 방식.

유저의 조작은 논타겟팅 처럼 액션감을 느낄 수있고, 실제로는 타겟팅 방식이기 떄문에 
서버의 로직은 가벼워진다. 또한 유저입장에서도 정확한 타겟팅으로 더 편리.


-----------------------------------------------------------------------------------------------


실시간 온라인 게임

대표적으로 MMO가 있다. 수많은 유저가 같은 공간에서 실시간으로 빠르게 움직이고,
전투를 하며 상호작용을 하는 게임이다.
이외에도 MOBA(AOS), FPS, 대전플레이 게임등 다양한 장르가 존재한다.

브롤스타즈와 같이 꼭 대규모의 유저가 플레이를 하지않는 게임(MO)도 실시간 온라인 게임이며,
Stateful게임서버로 개발되는 게임들이 있다.

MO는 P2P와 C/S방식으로 나누어지지만, C/S방식은 stateful게임서버 방식으로 개발.

LOL, 오버워치, 브롤스타즈 등은 MO게임이지만 C/S방식이며, 이는 Stateful게임서버의
기술을 사용하게된다.

클라는 서버에 접속해 연결을 유지한 상태로 플레이하며, 게임의 로직과 전투판정 등, 
모든 데이터와 결정은 게임서버가 주도적으로 진행해야 한다.

 '실시간 온라인 게임'의 서버는 Stateful Game Server라고 부른다.


-----------------------------------------------------------------------------------------------

비동기 실시간 온라인 게임

유저간의 상호작용이 없거나 제한적인 게임으로, 싱글게임에 가까운 온라인게임이다.
모바일 싱글RPG, 온라인 퍼즐게임, 방치형게임, 수집형 게임 등...

다른유저와의 실시간 플레이없이 싱글 플레이 후 데이터를 서버에 보관하거나,
다른 유저의 플레이 결과만을 교환 또는 확인, 선물전달, 랭킹 확인 등의 요소들로 제한된다.
이러한 게임들을 State Less Game Serveer라고 부른다.

-----------------------------------------------------------------------------------------------

비동기 온라인 게임에서 유저간 상호작용

다른 유저들의 마을을 공격하거나, 도움을 주는등의 상호작용이 존재한다.
위 상호작용은 완벽한 실시간이 아니며 서버에 저장된 과거의 데이터를 보여준다.

약간의 과거 데이터를 보여주어도 문제가없는 컨텐츠로 개발된다. (=비동기)

-----------------------------------------------------------------------------------------------

두 기술의 혼합형태

비동기 온라인 게임(stateless) + 실시간채팅(Stateful)
비동기 온라인 게임(stateless) + 실시간 PVP 인스턴스 던전(Stateful)
실시간 온라인 게임(stateful) + 랭킹 컨텐츠(stateless)
실시간 온라인 게임(stateful) + 로비, 캐릭터꾸미기(stateless)
실시간 온라인 게임(stateful) + 느슨한 상호작용 컨텐츠(stateless)

-----------------------------------------------------------------------------------------------

stateful 게임서버의 특징1 - 연결유지

유저의 게임 프로그램 클라이언트는 서버와 연결하여 유지.
(꼭 TCP의 Connect를 의미하는것은 아님)

연결의 개념을 유지하는 이유는 다른유저들의 행동을 모든 유저들에게 실시간으로 전송.


-----------------------------------------------------------------------------------------------

stateful 게임서버의 특징2 - 서버 메모리

접속한 유저들의 모든 게임 컨텐츠데이털르 게임서버 메모리에 보관, 실시간처리.
이는 빠르게 동기화된 로직처리르 위해 필수적인 부분이다.

서버 주도로 이동/공격 등 모든 컨텐츠가 처리되어야한다.

반대로 stateless서버는 서버의 메모리에 데이터를 보관하지않는다.

-----------------------------------------------------------------------------------------------

stateful 게임서버의 특징3 - 프로그래밍 언어

빠른 처리속도가 필수이므로 C/C++이 주력이다.
(간혹 C#, 스크립트언어, Java로 개발되기도 한다.)

-----------------------------------------------------------------------------------------------

stateful 게임서버의 특징4 - DB

게임서버의 몯느 로직은 서버의 메모리의 자료를 기반으로 처리한다.
따라서 DB활용도가 떨어진다.

1. 유저의 로그인요청 -> 유저의 모든데이터를 DB로부터 읽는다.
2. 로직변경시, 메모리를 변경/처리하고 변동사항을 DB에 저장한다.

-----------------------------------------------------------------------------------------------

stateful 게임서버의 특징5 - 확장, 분산 방식

스케일 아웃 - 수평적 확장 (물리 서버 개수를 늘림)
스케일 업 - 수직적 확장 (서버 성능을 높임)

stateful게임서버는 스케일아웃이 불가능하다. 따라서 동접자 제한이 존재한다.
단 완벽한 스케일 아웃은 아니더라도 게임자체를 나누거나 별도의 월드를 추가해 
수평확장과 비슷하게 처리할 수있음.

-----------------------------------------------------------------------------------------------

stateful에서의 스케일아웃

MMORPG - 유저가 서버군(월드)를 선택하여 플레이하도록 한다.
사용자가 많아지면 서버군(월드)를 더 추가하여 사용자에 대한 서버접속을 분산.

MO, MOBA, FPS - 유저들의 게임당 서버를 추가하여 유저가 더 많이 플레이 하게끔 함


위와같은 게임서버의 확장을 서버대수를 늘리는 scale-out이라고 부를 수 있음.
하나의 게임 타이틀 서비스 입장에서는 scale-out이지만, 플레이 단위로 본다면 X.

-----------------------------------------------------------------------------------------------

 비동기 온라인 게임서버, stateless서버

유저간의 상호작용이 없는 싱글게임, 완벽한 실시간 컨텐츠가 없는 게임에 적합
ex) 온라인 퍼즐게임, 방치형 게임, 수집형 게임, 실시간 동기화가 없는 모바일/웹게임 등

-----------------------------------------------------------------------------------------------

stateless게임서버의 특징 1 - 연결유지 없음

stateful과 다르게 연결유지 개념이 없다.
평소에 서버와 연결이 끊어진 상태로 단독 싱글플레이한다.
스테이지 클리어, 아이템사용, 구매, 가챠뽑기 등 중요포인트에서만 데이터를 전달하고,
서버로부터 결과를 반영, 수신하는 방식이다.

-----------------------------------------------------------------------------------------------

stateless게임서버의 특징 2 - 서버메모리에 데이터보관 없음

서버메모리 데이터상태 유무에 따라 stateless, stateful여부를 결정한다.
stateless의 연결이 끊어진 상태의 서버입장에서는 어떤 유저가 플레이 중인지,
어떤 플레이를 하는지 전혀 모름

서버는 필요시 마다 DB의 데이터를 읽어오고, 로직 처리 후 데이터 변경 후 저장하는 과정을
반복 수행

-----------------------------------------------------------------------------------------------

stateless게임서버의 특징 3 - 프로그래밍 언어

거의 대부분이 웹서버를 사용하므로, 웹서버 언어가 활용된다.
Node.Js / Python / PHP / Java 등 일반적인 웹프로그래밍 언어와 구조,설계,방법이 동일.

클라가 웹 브라우저가 아닌 게임클라이며, 서버로직이 게임로직일 뿐 일반적인 웹서버개발과 비슷

현재의 웹프로그래밍 언어들은 모두 스크립트 언어로서 C++과 같은 컴파일 언어에 비하면
성능이 많이 떨어지나, 개발과 유지보수에 편의성이 뛰어나므로 대중적이다.

-----------------------------------------------------------------------------------------------

stateless 게임서버의 특징 4 - 데이터베이스

stateful게임서버와 반대로 DB의존도와 활용도가 아주 높다.
연결 유지/메모리 데이터가 없기때문에 거의 모든 부담이 DB에서 나타난다.


1. 게임클라에서 스테이지 클리어
2. 클라가 서버에 연결, 클리어 정보 전달
3. 서버는 DB에서 유저스테이지 관련 정보 로딩
4. 서버는 해당 데이터로 클리어, 보상 등 컨텐츠 로직 처리
5. 서버는 처리된 데이터를 DB에 저장
6. 최종 결과를 클라에 전달
7. 연결 종료
8. 스테이지 클리어 결과 및 보상 표시

이처럼 특정 컨텐츠를 처리할 떄마다 위의 8단계 과정을 항시 반복수행한다.

stateful - 메모리가 최신데이터, 로직처리 기준, DB는 백업의 목적
stateless - 게임서버 상태/데이터 없음, DB가 최신 데이터이자 원본

-----------------------------------------------------------------------------------------------

stateless 게임서버의 특징 5 - 서버의 확장

스케일 아웃 확장이 가능하다. 서버자체에는 로직 코드만이 있을 뿐 데이터가 없으므로,
서버가 늘어나도, 어떤 서버에서 처리되어도 전혀상관없이 같은 데이터 결과를 본다.

대신 DB에 모든 데이터가 집중되기 때문에 DB의 성능/분산/설계가 중요하다.

-----------------------------------------------------------------------------------------------

stateful 장단점 정리

1. 연결유지로 인한 행동/변화에대한 즉각적 동기화가능
2. 빠른 처리속도로 실시간 온라인 게임 가능
3. 모든 게임의 로직을 서버가 전담하므로 핵이 불가능

1. 개발자체가 어려움
2. 서버가 다운되면 모든 유저 게임이 종료되며, 롤백 위험성있음
3. MMORPG같은 경우 한 서버당 접속자 제한이 생김(서버군, 채널분산)

-----------------------------------------------------------------------------------------------

stateless게임서버의 장점, 단점

1. 개발이 편리함 (언어자체 편의성, 라이브러리, 자료등이 많음)
2. 서버오류가 발생해도 일부 유저, 일부 기능에만 문제가 생김
3. 모든 데이터는 DB기준으로 처리 하기떄문에 서버다운의 롤백이 없음
4. 웹서버의 분산처리가 용이함

1. 서버와의 실시간 처리는 어려움이 있음
2. 일부 게임의 경우 클라이언트 단독 로직으로 인해 핵이 존재함.

-----------------------------------------------------------------------------------------------

Stateful과 stateless의 선택

게임장르에 따라 결정되며, 클라이언트의 플랫폼에 따라 결정되는 사항이 아니다.
MMORPG, MOBA, 스포츠, 액션 등 실시간 플레이를 다른유저와 한다면 stateful.
이런 요소가 없는 비동기형 게임이라면 stateless.

-----------------------------------------------------------------------------------------------


게임서버의 랙마운트 컴퓨터 규격 알기

일반적으로 서버 컴퓨터는 랙마운트 케이스를 사용한다.
서버라고 하여 다른컴퓨터와 큰 차이 없으며, 하드웨어 부분은 일반 웹서비스용 또는
기타 용도의 서버와 동일하다.

서버컴퓨터를 꼭 랙 케이스로 만들 필요는 없지만, 적은 공간에 많은 컴퓨털르 넣기위해
랙에 장착된느 케이스를 사용하게 된다.

특정 목적을 가진 (데이터 분석 / 저장 등) 아주 커다란 단독 서버 컴퓨터도 있지만
게임 또는 웹서비스를 목적으로 하는 어플리케이션 서버 컴퓨터는 최대한 작게만들어
수십대~수천대 이상의 서버 컴퓨터를 사용한다.

-----------------------------------------------------------------------------------------------

랙마운트 서버, 기본높이 1.75인치 : 4.445cm

이 사이즈를 1U(Unit)라고 표현한다

1U - 약 4.5cm
2U - 약 9 cm
3U - 약 13.5cm
4U - 약 18cm

일부 특이한 제품의 경우 1.5U처럼 하나 반 높이를 가지는 랙케이스도있지만 많이 사용X

-----------------------------------------------------------------------------------------------

랙마운트 서버, 너비 19인치 : 48.26cm

너비는 19인치 고정이며, 랙케이스 자체크기가 48.26cm이므로 손잡이, 랙 고정부를 제외한
실제 서버컴퓨터의 너비는 43cm정도된다.

서버뿐 아니라 대부분의 네트워크 장비들도 서버랙에 장착이 가능하다.

-----------------------------------------------------------------------------------------------

랙마운트 서버, 깊이 : 보통 50 ~ 70 cm

랙마운트 서버는 깊이(Depth)가 굉장히 다양하다. 
(깊이란 서버 전면부를 바라보았을때 뒤로 이어지는 길이를 뜻한다)

1U케이스의 경우 얇은 공간에 하드디스크, 메인보드, 파워서플라이, 쿨러등이 들어가므로
쌓아올리지 못하고 펼쳐서 구성. 부품들은 일반적으로 긴 길이를 가진다.

전면부 부터 디스크드라이브 > 쿨러 > 메인보드 > 파워서플라이 순서로 배치된다.
적은 공간에 많은 배치로 공기순환 X, 높이가 맞지않아 일부 PC부품들 사용 X

-----------------------------------------------------------------------------------------------

랙마운트 서버, 2U

2U크기부터는 일반 데스크탑과 비슷한 사이즈이기 때문에 내부에 사용하는 CPU쿨러,
케이스 쿨러, 파워서플라이 등은 서버용 제품이 아닌 일반제품을 사용할 수 있게된다.

서버 자체의 비용은 더 저렴해지지만 1U에 비해 공간을 두배로 사용하므로 유지비용상승

-----------------------------------------------------------------------------------------------

ITX보드용 소형 Rack

깊이가 25cm로 아주작은 사이즈이다. 이런제품은 발열 문제나 확장성이 
많이 떨어지기 때문에 고사양의 서버 컴퓨터보다 일반 산업용이나 저사양서버에 사용

작아서 관리하기는 편하지만 내부케이블이 빽빽하므로 지저분하게 구겨넣어야 들어가는케이스.

-----------------------------------------------------------------------------------------------

그외 다양한 크기 서버들

1U, 2U를 넘어서 더 큰 사이즈의 서버들은 뭔가 특성화된 기능이 있는것이 대부분.
데이터 저장용 스토리지서버나 최근에는 전자화폐 채굴용 컴퓨터를 랙마운트 형식으로
제작하는 경우가 있다.

-----------------------------------------------------------------------------------------------

더 작게 - 블레이드 서버

1U 보다 더 작은 공간에 더 많은 서버를 넣기위해 나온것이 블레이드 서버.
1U보다 더 작은 사이즈로 서버컴퓨터를 만들고, 블레이드 서버샤시에 끼워 사용.

아래의 사진은 중국산 저가형 블레이드 서버 케이스로 사이즈만 조금더 작을 뿐
일반 컴퓨터와 다른것이 전혀없다.

싸구려 서버케이스 제품이라도 블레이드 서버의 공간 효율성을 크게 느끼기는 어렵다.
8U크기의 샤시에 10개서버가 들어가는 구성이므로 서버가 2대분 더 들어갔다.

이런 제품도 블레이드 서버 디자인이므로 블레이드 서버라고 부를수있으나,
진짜 블레이드 서버와는 많이 다르다.

-----------------------------------------------------------------------------------------------

진짜 블레이드 서버

블레이드 서버는 I/O 파워서플라이 등 서버마다 공통적으로 사용되는 긴으들을 공유하여
효율성을 높이고, 각각의 모듈서버간 빠른 연결이 가능하여 분산처리에 더 좋은 성능을 
나타낸다.

아래는 HP사의 블레이드 서버로 하드디스크 랙 처럼 작은 모듈하나가 
한대의 서버역할을 하게된다.

단, 공간 효율성을 높이려다보니 가격이 매우 비싸다.
그리고 랙 설비시 전력문제도 빼놓을 수 없다.

초창기에는 서버혁신으로 모든 서버가 블레이드 서버로 대체될 분위기었으나,
생각보다 대중화가 덜 되었음.

-----------------------------------------------------------------------------------------------

게임서버 보관을 위한 서버랙 / 랙캐비넷


-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------