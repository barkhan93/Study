윈속 API함수는 성공시 0을 반환하는 경우가 많기 때문에 유의

------------------------------------------------------------
#pragma comment(lib, "ws2_32.lib")
#include <winsock2.h>
#include <ws2tcpip.h>	//InetPton

#define SERVER_PORT			6000
#define SERVER_IP			L"0.0.0.0"


void main()
{
	//윈속 초기화
	WSADATA wsa;
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
		return;

	SOCKET ListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	//SOCKET Socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	
	if (ListenSocket == INVALID_SOCKET)
		return;

	SOCKADDR_IN sockaddr;
	memset(&sockaddr, 0, sizeof(sockaddr));
	sockaddr.sin_family = AF_INET;
	sockaddr.sin_port = htons(SERVER_PORT);
	InetPtonW(AF_INET, SERVER_IP, &sockaddr.sin_addr);


	//연결
	if (bind(ListenSocket, (SOCKADDR*)&sockaddr, sizeof(sockaddr_in)) != 0)
		return;

	if (listen(ListenSocket, SOMAXCONN) != 0)
		return;

	/*
		Send - Recv 통신
	*/

	//윈속 종료

	closesocket(ListenSocket);
	WSACleanup();
}


WSAStartup은 여러번해도 문제X
대신 짝을 맞춰 Claenup을 호출해야함	

-------------------------------------------------------------

소켓

소켓생성시마다 리소스(버퍼 등)이 생성된다.
이는 논페이지드 풀 메모리가 사용된다.

TCP - 송수신 버퍼
UDP - 수신버퍼

소켓은 하나의 핸들로 인식되지만, 커널오브젝트는 아니다.
따라서 프로세스가 꺼지면 소켓관련 리소스는 모두 파괴된다.

-------------------------------------------------------------

closesocket

연결이 끊긴것과 리소스를 반환하는 것은 다른 개념이다.

소켓은 반환 후 즉시 할당을 할경우 반환한 값이 그대로 나오기때문에, 멀티스레딩 환경에서 문제가 되는 부분이다.

-------------------------------------------------------------

sockaddr_in

서버는 모든 연결자를 대상으로 상대방의 IP와 포트는 항상보관
구조체 자체를 보관하기도 한다.
-------------------------------------------------------------

바이트 정렬

데이터를 보낼때는 클랫폼 내부이기 때문에 신경쓸 필요 X
네트워크 장비들은 빅엔디안으로 주소를 보관하므로,
따라서 sockaddr_in(주소체계 저장) 구조체에 빅엔디안으로 저장

htons
ntohs

InetPton
ientNtop

로그를 찍을때 반대경우인 함수도 사용한다.

-------------------------------------------------------------

도메인

gethostbyname()

hostent* 타입을 리턴하고있는데, 해당 포인터의 메모리는 우리가 접근이 불가능하다.

따라서 해당방식은 멀티스레딩방식에서 안전하지 않다.



GetAddrInfo() - FreeaddrInfo()

4번째 인자로 리턴되는 ADDRINFO 내부의 sockaddr_in의 IN_ADDR
하나만을 사용한다. 내부에서 리스트형식으로 관리된다.
(도메인 하나당 여러개의 IP로 할당)

내부에서 동적할당을 하고있으므로 FreeaddrInfo를 호출해야함

추가적으로 내부에서 라운드로빈방식으로 리스트를 돌리고있음

-------------------------------------------------------------

Gethostbyaddr

(GetAddrInfo	도메인으로부터 IP를 알아낸 것)
Gethostbyaddr	IP로 부터 도메인을 알아내는 것

우리는 쓸일이 거의 없고, 이메일쪽에서 많이 활용한다.
(받는쪽에서 믿을수있게끔 역DNS를 가능하게 했음.)

-------------------------------------------------------------

기본적인 윈속 통신모양

서버
socket -> bind -> listen -> accept -> 통신(recv, send)

클라 
socket -> connect -> 통신(send, recv)

-------------------------------------------------------------

bind(ListenSocket, (SOCKADDR*)&sockaddr, sizeof(sockaddr_in)) 

소켓을 특정 주소와 포트에 연결시키는 행위

서버는 어디서 받아야 하는지 알아야하므로 bind필수
클라는 포트를 알아서 받으므로 bind하지않는 것을 권장

이더넷(랜카드) 하나당 IP가 하나씩 할당된다.

-------------------------------------------------------------

서버측 bind

모든 이더넷 카드로 받음 -> 0.0.0.0::5000
특정 포트를 열고 하나의 이더넷으로만 -> n.n1.n2.n3::5000

서버 컴퓨터마다 IP가 바뀌고 이는 세팅시 번거롭기 때문에
대부분은 0.0.0.0을 사용한다.


#define INADDR_ANY              (ULONG)0x00000000

-------------------------------------------------------------


클라측 bind

이더넷이 하나인 경우 경로가 모두 같다.
여러개인 경우 어디로 보낼것인지 라우팅한다.

윈도우는 게이트웨이(외부 이더넷)이 하나로 지정되므로
게이트웨이로 나가게된다.

내부망으로 Connect했는데 게이트웨이로 나가는 경우,
매트릭을 직접 수정하거나, 직접바인딩함

-------------------------------------------------------------

연결전 윈속API를 호출시, 

모든에러를 WSAGetLastError()를 통해 모두 확인 할 것

-------------------------------------------------------------

listen(ListenSocket, SOMAXCONN);

서버에서만 listen Socket을 만들어 listen을 호출한다.
상대방이 커넥트할 때 ListenSocekt으로 들어온다.

TCP는 연결이라는 개념이므로, 모든 클라의 정보를 저장한다.
(SOCKET, SOCKADDR_IN)

해당포트가 리스닝상태로 진입했다면, 이제 클라를 받을수 있게됨
클라쪽 Connect가 성공하게되는 것


-------------------------------------------------------------

Accept

SOCKET NewSocket = 
accept(pNetServer->_ListenSocket, (SOCKADDR*)&addr_in, &addrSize);

Accept는 클라이언트의 연결을 수립하는 것이 아니다.
연결된 클라를 백로그 큐에 저장해놓고 받는 것

-------------------------------------------------------------

backlog 큐

연결에 성공한 소켓들을 큐로 꽂아준다.
해당 큐의 한계치가 listen함수의 backlog의 개수이다.
Listen호출시 SOMAXCONN을 사용 (최대 200개)

#define SOMAXCONN       	0x7fffffff

#define SOMAXCONN_HINT(b) 	(-(b))
는 백로그 값이 b가되고 200~65535내로 조정된다.

-------------------------------------------------------------

backlog 큐와 관련된 연결 실패 문제

1. 백로그큐가 다차는 경우 SYN패킷을 즉시 파괴 -> Connect실패

2. 대량 연결시 backlog큐와 3WayHandShaking 동기화 문제

-> backlog큐 공간이 있어서 3Way를 시도했는데 backlogQ가 다참
서버는 backlog큐에 들어오지 못했으므로 accept하지못함

2의 증상
Connect 5천번 성공했는데 서버쪽Accept는 4990.
나머지 10개는 연결성공 후 끊김

2의 해결
backlog큐 최대치 늘림, 또는
if(accept카운팅 == connect카운팅)



-------------------------------------------------------------

Accept수치

TPS수치가 최소 5천명이상이 나오기 때문에
일반적인 클라에서는 절대 발생할수 없는 수치임.

단, 테스트를 할때는 유의할 것

-------------------------------------------------------------


하이재킹

서버-클라 통신시 TCP 시퀀스넘버 제어에 문제가있는 경우 이를 파고드는 공격

-------------------------------------------------------------

연결실패 시 

클라의 Connect이후 netstat - SYN_SENT상태인 경우 
서버쪽의 리슨, 포트번호, 방화벽 확인

-------------------------------------------------------------

Block - Nonblock

block	 	요청한 일을 즉시 수행할 수 없다면 block상태
Non-block	요청 후 즉시 그 다음작업을 처리 


bind와 listen은 실패 시 즉시 응답하므로 block되지않음
Accept는 backlogQ가 비었다면 block


Sync - Async 

Sync 	동기는 해당일이 처리될때 해당구문에 묶임
Async	비동기는 해당일이 다른곳에서 처리되고 나는 내할일함


동기 	- 블락, 논블락가능
비동기 	- 논블락만 가능


-------------------------------------------------------------

Send

내부 송신버퍼에 카피하여, 프로토콜 스택에 요청(보내는것 아님)
blockSocket의 경우 성공(Len) / 소켓에러 로 나뉨
Non-block의 경우 소켓에러 / 1~Len 등으로 다양하게 리턴

-------------------------------------------------------------
 
recv

수신버퍼에 들어있던 내용을 우리의 버퍼로 카피함
인자로 들어갈 버퍼는 maxsize로, 해당길이만큼 요청하는것 아님!
리턴값은 소켓에러, 

소켓에러 / 0 / 1~ Len 을 리턴

0은 rst(종료요청)가 온 경우이므로, 에러와 동급으로 처리
-> 연결끊음


recv리턴이 0인경우 2가지상황

1. 종료 요청이 온경우 
2. buffersize 가 0인경우 -> 이런상황은 나오면안됨

-------------------------------------------------------------

3Way HandShaking

사진참조(검색)

connect가 리턴되었다고해서 3WH가 완료된것은 아니다.
소켓 내부 라이브러리에 기억시키는 것.

-------------------------------------------------------------

4Way HandShaking

사진참조(검색)

FIN은 연결을 끊겠다는것이 아니라, send할게 없다고 통지
따라서 recv는 계속 진행되어야함.

graceful shutdown은 4Way handshaking으로 진행되는 정상종료.

-------------------------------------------------------------

closesocket의 역할

1. 소켓 리소스 반환
2. FIN 전송 (4Way handshaking진입)

-------------------------------------------------------------

shutdown

소켓리소스를 반환하지않고 종료절차만 진행한다.
인자로는

SD_RECV(받지않겠다) 
SD_SEND(보낼게 없다) 
SD_BOTH(둘다)

-------------------------------------------------------------

shutdown - SD_RECV(받지않겠다)

TCP헤더나 프로토콜 구조상 보낼게 없다(FIN)은 존재하나,
받지않겠다는 의미는 없다. 따라서 이인자는 할일이 없음

shutdown()을 호출후 recv에러가 나게끔해서 받지않음.

-------------------------------------------------------------

shutdown - SD_SEND(보낼게없다)

closetsocket은 4Wayhandshaking으로 진입시키고 소켓을 파괴
SD_SEND는 리소스를 파괴하지않고 SD_SEND한다.

FIN보내면 상대방이 ACK를 줄것이고,
그다음은 아무일도 하지않음. (이를 절반만 진행됐다 표현)

상대방도 보낼게 없어지면 FIN을 보낼 것



-------------------------------------------------------------

graceful shutdown 정리

보낼게 더이상 없다면 		shutdown(socket, SD_SEND)
상대가 더 보낼게 있는지 확인	shutdown(socket, SD_RECV)
그다음 리시브가 0인경우 closesocket으로 리소스 반환

-------------------------------------------------------------

4Way handshaking은 단순히 TCP종료 절차를 뜻함
Graceful shutdown은 프로그래머가 직접 구현하는 절차

게임서버에서는 이렇게 하지않음

-------------------------------------------------------------

4Way handShaking - FIN_WAIT1

FIN유실등의 이유로 상대방으로부터 응답이 없음
영원히 전달되지 않으므로 다시 보내야한다.

또는, 상대가 FIN을 받았는데 모종의 이유로 먹통이되어 응답없음.

-------------------------------------------------------------
4Way handShaking - FIN_WAIT2

우리쪽에서 Recv리턴값이 0이 나왔는데 그이후로 진입이안됨

-------------------------------------------------------------
4Way handShaking - CLOSE_WAIT

FIN에 대한 ACK를 보내고 멈춰있음.
(정상적인 경우는 내 FIN을 보내고 LAST_ACK상태로 진입)

-------------------------------------------------------------
4Way handShaking - TIME_WAIT

1. TIME_WAIT상태를 유지시켜 포트가 고갈되는 상황을 막음

메시지가 순서대로 오지않거나, 먼경로로 우회해 오는 경우
데이터가 FIN보다 늦게 도착하는 경우를 염두하여 만듬


2. 연결끊기 이후 패킷이 잘못된 프로세스에 도착하는 경우

-------------------------------------------------------------

TIME_WAIT이 필요없는 이유


1. 서버는 포트를 바인딩하여 사용, 클라는 안쓰는 포트를 동적할당

2. 포트번호, 시퀀스번호, IP번호까지 일치해야 함. (가능성 낮음)


추가로 소켓과 관련된 리소스는 Non-PagedMemory를 사용하므로 위험

-------------------------------------------------------------

서버의 클라 끊기

서버점검, 로그인정보 오류, 악의적인 connect(SYN Flooding)

정상클라인 경우 connect이후 로그인요청을 즉각 할것이기 때문에
몇초내에 반응이 없는경우 끊을 것.

-------------------------------------------------------------

Msg(L7) 구조체

pragma pack(push , 1)로 간다.
네트워크 송수신량을 줄이기 위함.

서버-클라가 완전히 같은 환경(컴파일러, OS, 비트)이라면 문제없으나 다를경우 위와같이 비는공간없이 데이터를 채워야함


단점 : 구조체를 모아놓은 헤더를 모두가 inclue -> 빌드시간증가

장점 : 성능 향상 (함수호출 x, Copy한번 줄어듬)

payload가 고정크기가 된다.


-------------------------------------------------------------

직렬화버퍼 

장점 : 플랫폼이 달라도 맞추기가 편함
단점 : 빈번한 함수호출, copy를 한번 더 하게됨

-------------------------------------------------------------

구조체 vs 직렬화버퍼

1. 성능차이 
2. 빌드 속도차이, 추가될때마다 리빌드
3. 구조체는 payload크기 고정(치명적)
4. 데이터 순서가 바뀌거나 사이즈 잘못잡는 오류생길 수있음.


채팅/퀘스트/인벤토리/선물함 등은 모두 가변길이이다.

아이템 리스트를 보내고싶을때 구조체 하나로 표현할수 없음.

-------------------------------------------------------------

가변길이가 붙게되는 컨텐츠 사용방법

1. 비동기 설계기반 (게임은 따로진행되고 아이템은 알아서 전송)
2. 메시지를 분리하여 시작과 끝을 알려줌
->아이템 인벤토리, 리스트 정보의 시작, 아이템정보 3종류

3. 직렬화 버퍼사용
4. 메시지 생성부 자동화

-------------------------------------------------------------

Msg모양

(Code) - Len - Type - CheckSum - Data

-------------------------------------------------------------

암호화

암호화란 3자로부터 보호를 막기위함으로, 어차피 클라에 복호화 키가 있기때문에 의미없으므로 게임서버는 암호화 X

말도안되는 값을 요청하는 경우 무시. (클라-서버의 핵심구조)

암호화를 하고싶다면 간단하게 패턴을 숨기는 정도

-------------------------------------------------------------

체크섬

복호화 하여 복호화된 데이터가 내것이 맞는지 확인하는 용도
위변조를 막기위해 사용

TCP는 100% 송수신이 보장되며 데이터가 깨지는 경우는 각 계층에서 알아서 해결한다.


-------------------------------------------------------------

소켓 옵션지정 (SOL_SOCKET)

setsockopt() 옵션레벨, 옵션define, 설정구조체를 넣어 옵션지정
getsockopt() 송수신 버퍼확인 / 지정이 가능. 이외에는 쓸일 X

(TCP) 리슨소켓에 옵션을 설정하면 리턴되는 모든 소켓이 자동세팅
-------------------------------------------------------------

SO_BROADCAST

내 네트워크 대역안에 모든 호스트에게 패킷을 송신

TCP는 연결의 개념이기때문에 브로드캐스팅이 불가능한 구조
브로드 캐스팅은 UDP전용이며, 호스트번호를 0xFFFFFFF로 만듬

내부 사설네트워크, 사내 메신저 등에 유용하게 사용됨
퀘이크, 스타1(LAN)같은 경우 방을 찾는것역시 브로드캐스팅.



-------------------------------------------------------------

SO_KEEPALIVE (L4에서 확인)

소켓API에 범용적으로 존재 (윈속전용 함수는 따로존재)

TCP는 연결(3WH)이후 연결상태를 확인하지않음.
따라서 L4계층에 문제가 생긴경우 이를 사용하면 파악가능.
단, 프로세스(L7)의 문제인 경우 파악하지못함.

서버에서는 send를 보냈을때 ACK가 오지않을 경우 몇번재전송 한다음
그래도 답이없으면 파괴 

-------------------------------------------------------------

서버쪽 timeout

모든 게임서버는 timeout체크 후 일정시간 송신이 없는 클라를끊음
L7에서 체크시 L4까지 자동적으로 체크가 가능.
따라서 keepalive는 테스트시에 사용


유저가 조작을 하지않는다고 하여 끊어지면 X
하트비트 메시지로 payload없이 연결상태를 확인하는 것


-------------------------------------------------------------

테스트환경 KeepAlive

더미를 끌때 FIN또는 RST가 유실되는 경우
netstat으로 판단해도 되지만 번거롭다면 KEEPALIVE를 사용

default인 2시간은 너무길기때문에 보통 1,20초로 설정해서 사용



BOOL bEnable = TRUE;
int retavl = setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (char*)&bEnable, sizeof(bEnable));
if (retval == SOCKET_ERROR) …;

이후 KEEPALIVE시간은 추가로 설정해줘야한다.


-------------------------------------------------------------

SO_LINGER(rst)

4WHS없이 rst로 파괴하는 것으로,
구체적으로는 closesocket이라는 함수의 행동을 정의한다.

단, 이미 shutdown()이나 LINGER옵션 없이 closeoscket을 호출하는등
FIN을 전송했다면 rst 종료는 불가능.

	LINGER linger;
	linger.l_onoff = 1; 
	linger.l_linger = 10;
	
	setsockopt(sock, SOL_SOCKET, SO_LINGER, (char*)&linger, sizeof(linger));

	if(retval == SOCKET_ERROR) ...

-------------------------------------------------------------

recv < rst(or FIN)

send를 성공하면 상대가 recv하지않아도 상대방 수신버에 쌓인다.
이때 closesocket을 하면 상대방은 수신버퍼에 있는 데이터를
recv하지않고, 연결끊기를 먼저 감지.

-------------------------------------------------------------

sockopt(SOCKET) – SO_SNDBUF, SO_RCVBUF


송수신버퍼를 조절할 때 위 항목을 사용한다.
이는 무조건 들어주는것이 아니라 커널에 요청하는 것


Send버퍼는 우리가 요청하는것으로, 원하는대로 조절 X
단, Nonblock 소켓의 경우는 0으로 가능


-------------------------------------------------------------

sockopt(SOCKET) - SO_SNDTIMEO, SO_RCVTIMEO

이 항목은 블락소켓일대, 블락되는 time_out을 지정하는 옵션
(default는 무한정 기다림)

-------------------------------------------------------------

sockopt(SOCKET) - SO_REUSEADDR

포트나 IP가 이미 TCP에 활용이 되고있을 때 재사용하게끔 한다.
정상작동 되지않으므로 사용하지않는다.

보통 TIME_WAIT으로 포트가 남을 수 있는 상황에서 이를 우회하는
방법중 하나로, 해당 포트가 사용중이더라도 덮어씌운다.

소켓API기준이므로, 윈도우에서 모든옵션이 똑같이 작동되지않음
된다고해도 딱히 쓸일 없음.

-------------------------------------------------------------

sockopt(TCP) - IPPROTO_TCP

네이글 여부를 결정한다.

NODELAY ON  = 네이글 끔 = 송신량 많아짐, 응답속도 상승
NODELAY OFF = 네이글 켬 = 송신량 적어짐, 응답속도 하락

네이글은 서버-클라가 각기 다르게 설정이 가능하다.

-------------------------------------------------------------

Nagle Algorithm

IP헤더 20, TCP헤더 20, MTU 1500, MSS 1460

버퍼에 데이터가 쌓이는 즉시 송신하면 트래픽이 커지기때문에,
어느정도 쌓아 놓고 보낸다. 


네이글이 켜졌을때 송신하는 조건

1. 상대방의 ACK가 도착 (3WHS에서 데이터가 안모여도 송신되는이유)
2. ACK가 오지않았으나 MSS size에 도달한 경우

단, 상대방의 윈도우사이즈가 없다면 전송X


-------------------------------------------------------------

sockopt(IP) - 

IP계층 옵션지정

IP계층은 사실상 사용할 만한게 없으므로 이론적인 것만 살펴봄.

멀티캐스팅의 IP주소 범위대역은 정해져있다.

224.1.1.1에 n명을 가입해놓고 해당IP로 오는 데이터만 받는형식
(224.1.1.1 = 가상목적지IP)

브로드캐스팅 / 멀티캐스팅은 게이트웨이로 나갈 이유가없으므로 드랍

