UDP

UDP는 연결이라는 개념이 없기때문에, connect가 없음
매번 send할때마다 목적지를 지정하여 sendto() / recvfrom()

-------------------------------------------------------------

Ioctlsocket()

논블락 소켓으로 전환할때 사용

	int err;
	u_long on = 1;
	err = ioctlsocket(sock, FIONBIO, &on);
	if (err == SOCKET_ERROR) return -1;

non-blocked소켓은 항상 에러가 날 수있는 상황이 되었음.

따라서 WSAEWOULDBLOCK(조건 만족X)으로 에러와 구분한다.

(WSA_IO_PENDING은 비동기 작업으로 전환되었음을 의미)

-------------------------------------------------------------

모든 프로그램(프로세스/스레드)는 할일이 있다면 하고,
없다면 쉬어야(block)한다.

busy wait과같은 상태는 특수한 상황이 아니고서야 사용 X

-------------------------------------------------------------

Socket model 

소켓모델은 기본적으로 send/recv/accept를 할수있는 상황인지 판단

listenSocket넣음 - backlog큐 확인
recv - 수신버퍼에 받은 데이터 있는지 확인
send - 송신버퍼에 공간 있는지 확인

-------------------------------------------------------------

Socket model - Select

select는 버클리소켓(리눅스), 윈속 모두에 존재.
옛날방식이나 IOCP를 엉터리로 쓰는 경우 Select보다 성능이 안나옴

block소켓 	- block되는 상태를 막음
non-block소켓	- 나중에 호출해야 하는 상태 막음 

-------------------------------------------------------------


Select모델에서 block소켓을 쓰는경우

일반적으로는 Select모델에서 blocked소켓을 사용한다.
block걸릴일은 거의 0에 가까우나, 딱한가지 예외상황으로

send시 송신버퍼에 공간이 없는경우

recv는 받을게 있는것만 뽑으므로 block되지않을 것.


-------------------------------------------------------------

Select 모델의 사용처

언리얼의 데디케이트서버역시 Select모델
구조가 간단하고 안전하므로 더미구현시 용이

-------------------------------------------------------------

select 모양

#define FD_SETSIZE      64
typedef struct fd_set 
{
        u_int 	fd_count;               
        SOCKET  fd_array[FD_SETSIZE];   
} fd_set;


int WSAAPI select
(
  int           nfds,		//무시
  fd_set        *readfds,	
  fd_set        *writefds,
  fd_set        *exceptfds,  //OOB메시지. 제외.
  const timeval *timeout
);

반환값 : 조건을 만족하는 개수또는 0(타임아웃). 실패시 소켓에러
이 값으로 소켓을 찾아 로직처리.

FD_SET 64

-------------------------------------------------------------

excceptfds

OOB를 뜻하므로 사용하지않음.
단, Connect 실패시 이쪽으로 알려준다. 

Connect성공은 write 성공한다면 연결성공여부 알수있음.


-------------------------------------------------------------

timeval

Select를 통해 아무도 반응이없다면 기다리는 시간.
어떤 반응이 있다면 즉시 리턴함.

0을 넣을경우 무한정 대기(block)

-------------------------------------------------------------

Select모델 사용순서

1. 소켓셋 초기화 (FD_SET)
2. 소켓셋에 소켓넣기(64 - 1(ListenSocket))
3. Select호출 (반응이 없는경우 block)
4. 남아있는 소켓에 대해 로직처리

-------------------------------------------------------------

writeset을 사용하지 않는 구조 (우리가 사용)

send를 해야하는 상황마다 select를 호출할 수는 없음

송신버퍼가 가득 차는 상황은 거의없음
(상대방 윈도우 사이즈0, 내송신버퍼 가득참)

이 경우 send를 하고싶을때 아무데서나 하고있기 때문에,
세션삭제가 문제가 될 가능성이 있다.
-------------------------------------------------------------

writeset을 사용하는 구조 (정석)

L7에 송신링버퍼를 만들어 send를 할때 버퍼에 모아놓고 
Select를 거쳐 보낼수있다면 Send.

-------------------------------------------------------------

FD_ZERO  - 셋을 비운다(초기화)
FD_SET	 - 셋에 소켓을 넣음
FD_CLR	 - 셋에 소켓 제거
FD_ISSET - 특정소켓을 찾아줌 (없으면 0)

-------------------------------------------------------------

데이터가 조각이 나는 경우

1. 상대방의 윈도우 사이즈 0
2. Nagle이 켜졌다면) ACK도착, MSS도달시 일단 송신


위 경우들이 거의 나오지 않는 이유

1.   상대방의 윈도우 사이즈가 0인경우 문제가 있는상황
2.   MSS에 도달할 일은 거의 없을것
2.1. ACK가 오면 조각나는거 아닌가..?

-------------------------------------------------------------

Select Connect(클라) 

Connect가 실패하면 블락걸린다.
따라서 Select루프 바깥으로 뺀다.

하지만 Non-block소켓이므로 Select가 곧바로 결과를 주지못함.
따라서 300m/s정도로 연결실패를 판단한다.

-------------------------------------------------------------

Msg 지역 사용

여러군데서 접근한다고하여 전역에서 사용하는것은 오히려 성능저하

전역변수는 최적화 하기 힘듬..

-------------------------------------------------------------

섹터관련 로직처리

게임서버에서 가장큰 부담을 차지한다.
맵에 등록시 주변오브젝트에 이를 알리는 것.

-------------------------------------------------------------

select 구조에서 로직처리의 형평성

select모델은 루프를돌면서 차례로 로직을 처리한다.


1. 앞쪽에 있는 유저처리량이 더 빠른것 아닌가?
for문 시점에 따라 달라질것이므로 무의미하다.
더군다나 찰나의 순간이므로 유저가 느끼는것은 불가능

2. 특정클라가 많은 데이터를 송신하는 경우는?

이는 컨텐츠쪽에서 메시지의 텀이나 규칙으로 횟수를 지정하는 방식
으로 걸러낸다.

-------------------------------------------------------------

C# vs IOCP

IOCP를 사용하는 경우 최소한 2천만 TPS는 나와야한다.
그렇지 않은경우 C#으로 가는게 낫다.

CGC엔진의 경우 초당 4천만.

-------------------------------------------------------------

UDP

sendto(), recvfrom()

연결개념이 없으므로 connect() 사용하지않는다.
TCP에서 제공되는 안전장치가 전혀없다. (ACK, SEQ, 등..)

데이터가 왔을때 포함된 주소로 우리가 직접 세션을 찾아야한다.

-------------------------------------------------------------

링버퍼(생략)

-------------------------------------------------------------

Send와 Recv호출은 굉장히 느리다.
수시로 링버퍼에서 메모리가 카피되는것을 걱정할 필요없음.

-------------------------------------------------------------

WSAAsyncSeclt

윈도우 핸들이 존재해야하므로 클라가 윈도우여야만 한다.
따라서 서버쪽에서는 쓰지않음.

멀티스레딩/멀티코어 환경에서도 적합하지않음.

하지만 모든모델은 현역이며, 무시할만한 수준은 아님

-------------------------------------------------------------

int WSAAsyncSelect
(
    SOCKET s,       //등록할 소켓
    HWND   hWnd,
    u_int  wMsg,    
    long   lEvent  
);

네트워크 이벤트가 발생하면 Msg로 메시지가 도착.
따로 정의되어있지 않으므로 WM_USER + n 형태로 정의하여 사용

Event는 비트마스크 조합으로 나타내게 된다.

-------------------------------------------------------------


WSAAsyncSeclt 특징

1. 소켓을 AsyncSelect에 등록하면 자동으로 논블락으로 전환된다.
2. Accpet가 리턴하는 소켓은 listsocket과 동일한 속성 가짐
3. 윈도우 메시지를 대상으로 소켓함수를 호출할경우 간혹 WOULDBLOCK
이 나올때가 있음.

4. 윈도우 메시지를 받았을때 적절한 함수호출 안하면,
다음번엔 같은 윈도우메시지 발생 X

-> FD_READ이벤트 발생 -> recv 호출안함 -> 해당소켓은 FD_READ이벤트
발생안함
(단, L7버퍼가 모자라 프로토콜 수신버퍼에 있는것을 못빼냈다면 이때는
FD_READ가 뜬다.)

-------------------------------------------------------------

FD_WRITE 특징

1. 연결이 처음 된 시점에 반응
2. 송신버퍼를 일부러 채운다음, 비워지는 시점

따라서 AsnycSelect는 Send를 하고싶을때 하는 구조이다.

-------------------------------------------------------------

LRESULT WndProc
(
	HWND hWnd,  	// 
	UINT message,	// Asycselect()호출 시 등록한 사용자정의msg
	WPARAM wParam,  // 이벤트가 발생한 소켓
	LPARAM lParam	// 하위 16비트는 발생한 네트워크 이벤트,
			// 상위 16비트는 오류코드를 담고있음.
);

여기서는 WSAGetLastError()함수로 오류코드를 알아낼 수 없음..


WSAGETSELECTERROR(lParam) HIWORD(lParam)
WSAGETSELECTEVENT(wParam) LOWORD(lParam)

WinProc에서는 제일먼저 WSAGETSELECTERROR()로 에러를 확인한다.!

FD_READ, FD_WRITE같은 이벤트는 동시에 발생되어도 하나씩 온다.

서버에서는 FD_ACCEPT에서 접속한 클라를 대상으로 AsyncSelect등록.

-------------------------------------------------------------


WSAAsyncSelect 클라이언트 구조

main()
{
	윈도우 생성
	소켓 생성
	WSAAsyncSelect
	(
		Socket, hWnd, UM_NETWORK, 
		FD_CONNECT | FD_CLOSE | FD_READ | FD_WRITE
	);

	ret = connect();
	if(fet == SOCKET_ERROR)
		if(WSAGetLastError() != WSAEWOULDBLOCK)
			에러상황

	while (true)
	{
		//윈도우 메시지 루프...
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			if (msg.message == WM_QUIT)
				break;

			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
		else
		{
			if (g_Connect == TRUE) //연결됐으면 루프
				GamePlay();
		}
	}

}


------------------------------------------------------------

WndProc()

WndProc()
{
	case UM_NETWORK;
		
		if(WSAGETSELECTERROR(lParam))
        		에러처리, 연결종료
      			
      switch(WSAGETEVENTSELECT(lParam))
      {
	case FD_CONNECT:
	g_Connect = TRUE; (연결됐다는 알림을 추가해도 좋음.)

	case FD_READ
	ProcRead(); 
	break;
   
	case FD_WRITE;
	g_Send = true;   
	//FD_WRITE가 호출되었으므로 Send플래그를 바꿔준다.
 	ProcWrite();
}
//신호가왔을때 Send를 모두 보내야하므로, 다음과같은 반복문을 돌게된다.
   while(1) //1234
   {
      if(SendQ.GetUseSize() <= 0) 또는 WOULDBLOCK이 떴다라면, 중지.
         break;
   }

   case FD_CLOSE:
}


-------------------------------------------------------------

굳이 SendFlag를 사용하는 이유

WOULDBLOCK이 뜬다음에는 아무리 send를 시도해도 FD_WRITE가
뜨기전까지는 계속 WOULDBLOCK상태이다.

따라서 SendFlag를 넣어 불필요한 send호출을 줄인다.

-------------------------------------------------------------

SendPacket()

FD_READ나 FD_WRITE에서 호출하는것이 아니라
Send하고싶을때마다 호출한다.

-------------------------------------------------------------

Event방식에서의 Send

Event방식에서는 Event가 왔을때 SendQ에 있는것을 모두 뽑아보냄.
그렇지않으면 아무도 보내지않기 때문.




-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
-------------------------------------------------------------
